// This file is @generated by prost-build.
/// Service message to encapsulate unique and semantic identifiers for a service on the network
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Service {
    /// For example, what if we want to request a session for a certain service but with some additional configs that identify it?
    ///
    /// Unique identifier for the service
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// TODO_POST_MAINNET: Rename service.name to service.description
    ///
    /// (Optional) Human readable description of the service
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// The cost of a single relay for this service in terms of compute units.
    /// Must be used alongside the global 'compute_units_to_tokens_multiplier' to calculate the cost of a relay for this service.
    /// cost_per_relay_for_specific_service = compute_units_per_relay_for_specific_service * compute_units_to_tokens_multiplier_global_value
    ///
    /// Compute units required per relay for this service
    #[prost(uint64, tag = "3")]
    pub compute_units_per_relay: u64,
    /// The owner address that created the service.
    /// It is the address that receives rewards based on the Service's onchain usage
    /// It is the only address that can update the service configuration (e.g. compute_units_per_relay),
    /// or make other updates to it.
    ///
    /// The Bech32 address of the service owner / creator
    #[prost(string, tag = "4")]
    pub owner_address: ::prost::alloc::string::String,
}
impl ::prost::Name for Service {
    const NAME: &'static str = "Service";
    const PACKAGE: &'static str = "pocket.shared";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.shared.Service".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.shared.Service".into()
    }
}
/// ApplicationServiceConfig holds the service configuration the application stakes for
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ApplicationServiceConfig {
    /// The Service ID for which the application is configured
    #[prost(string, tag = "1")]
    pub service_id: ::prost::alloc::string::String,
}
impl ::prost::Name for ApplicationServiceConfig {
    const NAME: &'static str = "ApplicationServiceConfig";
    const PACKAGE: &'static str = "pocket.shared";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.shared.ApplicationServiceConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.shared.ApplicationServiceConfig".into()
    }
}
/// SupplierServiceConfig holds the service configuration the supplier stakes for
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SupplierServiceConfig {
    /// The Service ID for which the supplier is configured
    #[prost(string, tag = "1")]
    pub service_id: ::prost::alloc::string::String,
    /// List of endpoints for the service
    #[prost(message, repeated, tag = "2")]
    pub endpoints: ::prost::alloc::vec::Vec<SupplierEndpoint>,
    /// List of revenue share configurations for the service
    #[prost(message, repeated, tag = "3")]
    pub rev_share: ::prost::alloc::vec::Vec<ServiceRevenueShare>,
}
impl ::prost::Name for SupplierServiceConfig {
    const NAME: &'static str = "SupplierServiceConfig";
    const PACKAGE: &'static str = "pocket.shared";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.shared.SupplierServiceConfig".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.shared.SupplierServiceConfig".into()
    }
}
/// SupplierEndpoint message to hold service configuration details
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SupplierEndpoint {
    /// URL of the endpoint
    #[prost(string, tag = "1")]
    pub url: ::prost::alloc::string::String,
    /// Type of RPC exposed on the url above
    #[prost(enumeration = "RpcType", tag = "2")]
    pub rpc_type: i32,
    /// Additional configuration options for the endpoint
    #[prost(message, repeated, tag = "3")]
    pub configs: ::prost::alloc::vec::Vec<ConfigOption>,
}
impl ::prost::Name for SupplierEndpoint {
    const NAME: &'static str = "SupplierEndpoint";
    const PACKAGE: &'static str = "pocket.shared";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.shared.SupplierEndpoint".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.shared.SupplierEndpoint".into()
    }
}
/// ServiceRevenueShare message to hold revenue share configuration details
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceRevenueShare {
    /// The Bech32 address of the revenue share recipient
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    /// The percentage of revenue share the recipient will receive
    #[prost(uint64, tag = "3")]
    pub rev_share_percentage: u64,
}
impl ::prost::Name for ServiceRevenueShare {
    const NAME: &'static str = "ServiceRevenueShare";
    const PACKAGE: &'static str = "pocket.shared";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.shared.ServiceRevenueShare".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.shared.ServiceRevenueShare".into()
    }
}
/// Key-value wrapper for config options, as proto maps can't be keyed by enums
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConfigOption {
    /// Config option key
    #[prost(enumeration = "ConfigOptions", tag = "1")]
    pub key: i32,
    /// Config option value
    #[prost(string, tag = "2")]
    pub value: ::prost::alloc::string::String,
}
impl ::prost::Name for ConfigOption {
    const NAME: &'static str = "ConfigOption";
    const PACKAGE: &'static str = "pocket.shared";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.shared.ConfigOption".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.shared.ConfigOption".into()
    }
}
/// Enum to define RPC types
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RpcType {
    /// Undefined RPC type
    UnknownRpc = 0,
    /// gRPC
    Grpc = 1,
    /// WebSocket
    Websocket = 2,
    /// JSON-RPC
    JsonRpc = 3,
    /// REST
    Rest = 4,
}
impl RpcType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnknownRpc => "UNKNOWN_RPC",
            Self::Grpc => "GRPC",
            Self::Websocket => "WEBSOCKET",
            Self::JsonRpc => "JSON_RPC",
            Self::Rest => "REST",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN_RPC" => Some(Self::UnknownRpc),
            "GRPC" => Some(Self::Grpc),
            "WEBSOCKET" => Some(Self::Websocket),
            "JSON_RPC" => Some(Self::JsonRpc),
            "REST" => Some(Self::Rest),
            _ => None,
        }
    }
}
/// Enum to define configuration options
/// TODO_RESEARCH: Should these be configs, SLAs or something else? There will be more discussion once we get closer to implementing onchain QoS.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ConfigOptions {
    /// Undefined config option
    UnknownConfig = 0,
    /// Timeout setting
    Timeout = 1,
}
impl ConfigOptions {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::UnknownConfig => "UNKNOWN_CONFIG",
            Self::Timeout => "TIMEOUT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UNKNOWN_CONFIG" => Some(Self::UnknownConfig),
            "TIMEOUT" => Some(Self::Timeout),
            _ => None,
        }
    }
}
/// Supplier represents an actor in Pocket Network that provides RPC services
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Supplier {
    /// Owner address that controls the staked funds and receives rewards by default
    /// Cannot be updated by the operator
    #[prost(string, tag = "1")]
    pub owner_address: ::prost::alloc::string::String,
    /// Operator address managing the offchain server
    /// Immutable for supplier's lifespan - requires unstake/re-stake to change.
    /// Can update supplier configs except for owner address.
    #[prost(string, tag = "2")]
    pub operator_address: ::prost::alloc::string::String,
    /// Total amount of staked uPOKT
    #[prost(message, optional, tag = "3")]
    pub stake: ::core::option::Option<super::super::cosmos::base::v1beta1::Coin>,
    /// List of service configurations supported by this supplier
    #[prost(message, repeated, tag = "4")]
    pub services: ::prost::alloc::vec::Vec<SupplierServiceConfig>,
    /// Session end height when supplier initiated unstaking (0 if not unstaking)
    #[prost(uint64, tag = "5")]
    pub unstake_session_end_height: u64,
    /// List of historical service configuration updates, tracking the suppliers
    /// services update and corresponding activation heights.
    #[prost(message, repeated, tag = "6")]
    pub service_config_history: ::prost::alloc::vec::Vec<ServiceConfigUpdate>,
}
impl ::prost::Name for Supplier {
    const NAME: &'static str = "Supplier";
    const PACKAGE: &'static str = "pocket.shared";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.shared.Supplier".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.shared.Supplier".into()
    }
}
/// ServiceConfigUpdate tracks a change in a supplier's service configurations
/// at a specific block height, enabling tracking of configuration changes over time.
/// This record helps maintain a complete history of service configs and their availability periods.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServiceConfigUpdate {
    /// Operator address of the supplier corresponding to the service configuration change
    #[prost(string, tag = "1")]
    pub operator_address: ::prost::alloc::string::String,
    /// The specific service configuration that was added, modified or scheduled for removal
    #[prost(message, optional, tag = "2")]
    pub service: ::core::option::Option<SupplierServiceConfig>,
    /// Block height at which this service configuration became active in the network
    #[prost(int64, tag = "3")]
    pub activation_height: i64,
    /// Block height at which this service configuration was deactivated (0 if still active)
    /// For service configs scheduled for deactivation:
    /// - This field stores the block height when deactivation will occur
    /// - After deactivation, the config remains in history only as needed for claim settlement
    /// - Once no longer required for settlement, the config is automatically removed by
    ///    the EndBlockerPruneSupplierServiceConfigHistory process
    #[prost(int64, tag = "4")]
    pub deactivation_height: i64,
}
impl ::prost::Name for ServiceConfigUpdate {
    const NAME: &'static str = "ServiceConfigUpdate";
    const PACKAGE: &'static str = "pocket.shared";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.shared.ServiceConfigUpdate".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.shared.ServiceConfigUpdate".into()
    }
}
/// Params defines the parameters for the module.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Params {
    /// num_blocks_per_session is the number of blocks between the session start & end heights.
    #[prost(uint64, tag = "1")]
    pub num_blocks_per_session: u64,
    /// grace_period_end_offset_blocks is the number of blocks, after the session end height,
    /// during which the supplier can still service payable relays.
    /// Suppliers will need to recreate a claim for the previous session (if already created) to
    /// get paid for the additional relays.
    #[prost(uint64, tag = "2")]
    pub grace_period_end_offset_blocks: u64,
    /// claim_window_open_offset_blocks is the number of blocks after the session grace
    /// period height, at which the claim window opens.
    #[prost(uint64, tag = "3")]
    pub claim_window_open_offset_blocks: u64,
    /// claim_window_close_offset_blocks is the number of blocks after the claim window
    /// open height, at which the claim window closes.
    #[prost(uint64, tag = "4")]
    pub claim_window_close_offset_blocks: u64,
    /// proof_window_open_offset_blocks is the number of blocks after the claim window
    /// close height, at which the proof window opens.
    #[prost(uint64, tag = "5")]
    pub proof_window_open_offset_blocks: u64,
    /// proof_window_close_offset_blocks is the number of blocks after the proof window
    /// open height, at which the proof window closes.
    #[prost(uint64, tag = "6")]
    pub proof_window_close_offset_blocks: u64,
    /// supplier_unbonding_period_sessions is the number of sessions that a supplier must wait after
    /// unstaking before their staked assets are moved to their account balance.
    /// Onchain business logic requires, and ensures, that the corresponding block count of the unbonding
    /// period will exceed the end of any active claim & proof lifecycles.
    #[prost(uint64, tag = "7")]
    pub supplier_unbonding_period_sessions: u64,
    /// application_unbonding_period_sessions is the number of sessions that an application must wait after
    /// unstaking before their staked assets are moved to their account balance.
    /// Onchain business logic requires, and ensures, that the corresponding block count of the
    /// application unbonding period will exceed the end of its corresponding proof window close height.
    #[prost(uint64, tag = "8")]
    pub application_unbonding_period_sessions: u64,
    /// The amount of tokens that a compute unit should translate to when settling a session.
    /// It is denominated in fractional uPOKT (1/compute_unit_cost_granularity)
    /// DEV_NOTE: This used to be under x/tokenomics but has been moved here to avoid cyclic dependencies.
    #[prost(uint64, tag = "9")]
    pub compute_units_to_tokens_multiplier: u64,
    /// gateway_unbonding_period_sessions is the number of sessions that a gateway must wait after
    /// unstaking before their staked assets are moved to its account balance.
    #[prost(uint64, tag = "10")]
    pub gateway_unbonding_period_sessions: u64,
    /// compute_unit_cost_granularity is the fraction of the base unit (uPOKT) used
    /// to represent the smallest price of a single compute unit.
    /// compute_unit_cost_granularity defines the smallest fraction of uPOKT that can represent
    /// the cost of a single compute unit.
    ///
    /// It acts as a denominator in the formula:
    ///
    ///    compute_unit_cost_in_uPOKT = compute_units_to_tokens_multiplier / compute_unit_cost_granularity
    ///
    /// This enables high-precision pricing of compute units using integer math.
    /// For example:
    ///
    /// +-------------------------------+---------------------------------------------+
    /// | compute_unit_cost_granularity | compute_units_to_tokens_multiplier unit     |
    /// +-------------------------------+---------------------------------------------+
    /// | 1                             | uPOKT                                       |
    /// | 1_000                         | nPOKT (nanoPOKT, 1e-3 uPOKT)                |
    /// | 1_000_000                     | pPOKT (picoPOKT, 1e-6 uPOKT)                |
    /// +-------------------------------+---------------------------------------------+
    ///
    /// ⚠️ Note: This value is a configurable global network parameter (not a constant).
    /// It must be a power of 10, allowing precise denomination shifts without affecting
    /// ongoing sessions. This prevents sessions from settling using parameters that
    /// were not in effect during their creation.
    #[prost(uint64, tag = "11")]
    pub compute_unit_cost_granularity: u64,
}
impl ::prost::Name for Params {
    const NAME: &'static str = "Params";
    const PACKAGE: &'static str = "pocket.shared";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.shared.Params".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.shared.Params".into()
    }
}
/// GenesisState defines the shared module's genesis state.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GenesisState {
    /// params defines all the parameters of the module.
    #[prost(message, optional, tag = "1")]
    pub params: ::core::option::Option<Params>,
}
impl ::prost::Name for GenesisState {
    const NAME: &'static str = "GenesisState";
    const PACKAGE: &'static str = "pocket.shared";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.shared.GenesisState".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.shared.GenesisState".into()
    }
}
/// QueryParamsRequest is request type for the Query/Params RPC method.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryParamsRequest {}
impl ::prost::Name for QueryParamsRequest {
    const NAME: &'static str = "QueryParamsRequest";
    const PACKAGE: &'static str = "pocket.shared";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.shared.QueryParamsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.shared.QueryParamsRequest".into()
    }
}
/// QueryParamsResponse is response type for the Query/Params RPC method.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryParamsResponse {
    /// params holds all the parameters of this module.
    #[prost(message, optional, tag = "1")]
    pub params: ::core::option::Option<Params>,
}
impl ::prost::Name for QueryParamsResponse {
    const NAME: &'static str = "QueryParamsResponse";
    const PACKAGE: &'static str = "pocket.shared";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.shared.QueryParamsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.shared.QueryParamsResponse".into()
    }
}
/// Generated client implementations.
pub mod query_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Query defines the gRPC querier service.
    #[derive(Debug, Clone)]
    pub struct QueryClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl QueryClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> QueryClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> QueryClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            QueryClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Parameters queries the parameters of the module.
        pub async fn params(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryParamsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryParamsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pocket.shared.Query/Params",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pocket.shared.Query", "Params"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// MsgUpdateParams is the Msg/UpdateParams request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUpdateParams {
    /// authority is the address that controls the module (defaults to x/gov unless overwritten).
    #[prost(string, tag = "1")]
    pub authority: ::prost::alloc::string::String,
    /// NOTE: All parameters must be supplied.
    #[prost(message, optional, tag = "2")]
    pub params: ::core::option::Option<Params>,
}
impl ::prost::Name for MsgUpdateParams {
    const NAME: &'static str = "MsgUpdateParams";
    const PACKAGE: &'static str = "pocket.shared";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.shared.MsgUpdateParams".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.shared.MsgUpdateParams".into()
    }
}
/// MsgUpdateParamsResponse defines the response structure for executing a
/// MsgUpdateParams message.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgUpdateParamsResponse {}
impl ::prost::Name for MsgUpdateParamsResponse {
    const NAME: &'static str = "MsgUpdateParamsResponse";
    const PACKAGE: &'static str = "pocket.shared";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.shared.MsgUpdateParamsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.shared.MsgUpdateParamsResponse".into()
    }
}
/// MsgUpdateParam is the Msg/UpdateParam request type to update a single param.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUpdateParam {
    /// authority is the address that controls the module (defaults to x/gov unless overwritten).
    #[prost(string, tag = "1")]
    pub authority: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(oneof = "msg_update_param::AsType", tags = "3, 6, 7")]
    pub as_type: ::core::option::Option<msg_update_param::AsType>,
}
/// Nested message and enum types in `MsgUpdateParam`.
pub mod msg_update_param {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum AsType {
        #[prost(string, tag = "3")]
        AsString(::prost::alloc::string::String),
        #[prost(uint64, tag = "6")]
        AsUint64(u64),
        #[prost(bytes, tag = "7")]
        AsBytes(::prost::alloc::vec::Vec<u8>),
    }
}
impl ::prost::Name for MsgUpdateParam {
    const NAME: &'static str = "MsgUpdateParam";
    const PACKAGE: &'static str = "pocket.shared";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.shared.MsgUpdateParam".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.shared.MsgUpdateParam".into()
    }
}
/// MsgUpdateParamResponse defines the response structure for executing a
/// MsgUpdateParam message after a single param update.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgUpdateParamResponse {
    #[prost(message, optional, tag = "1")]
    pub params: ::core::option::Option<Params>,
}
impl ::prost::Name for MsgUpdateParamResponse {
    const NAME: &'static str = "MsgUpdateParamResponse";
    const PACKAGE: &'static str = "pocket.shared";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.shared.MsgUpdateParamResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.shared.MsgUpdateParamResponse".into()
    }
}
/// Generated client implementations.
pub mod msg_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Msg defines the Msg service.
    #[derive(Debug, Clone)]
    pub struct MsgClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl MsgClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> MsgClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MsgClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            MsgClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// UpdateParams defines a (governance) operation for updating the module
        /// parameters. The authority defaults to the x/gov module account.
        pub async fn update_params(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgUpdateParams>,
        ) -> std::result::Result<
            tonic::Response<super::MsgUpdateParamsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pocket.shared.Msg/UpdateParams",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pocket.shared.Msg", "UpdateParams"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn update_param(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgUpdateParam>,
        ) -> std::result::Result<
            tonic::Response<super::MsgUpdateParamResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pocket.shared.Msg/UpdateParam",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pocket.shared.Msg", "UpdateParam"));
            self.inner.unary(req, path, codec).await
        }
    }
}
