// This file is @generated by prost-build.
/// MorseAccountState is the onchain representation of all account state to be migrated from Morse.
/// It is NEVER persisted onchain but is a dependency of the MsgImportMorseClaimableAccount handler.
/// It's main purpose is to expose the #GetHash() method for verifying the integrity of all MorseClaimableAccounts.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MorseAccountState {
    #[prost(message, repeated, tag = "2")]
    pub accounts: ::prost::alloc::vec::Vec<MorseClaimableAccount>,
}
impl ::prost::Name for MorseAccountState {
    const NAME: &'static str = "MorseAccountState";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MorseAccountState".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MorseAccountState".into()
    }
}
/// MorseClaimableAccount is the onchain (persisted) representation of a Morse
/// account which is claimable as part of the Morse -> Shannon migration.
/// They are intended to be created during MorseAccountState import (see: MsgImportMorseClaimableAccount).
/// It is created ONLY ONCE and NEVER deleted (per morse_src_address per network / re-genesis).
/// It is updated ONLY ONCE, when it is claimed (per morse_src_address per network / re-genesis).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MorseClaimableAccount {
    /// The bech32-encoded address of the Shannon account to which the claimed balance will be minted.
    /// This field is intended to remain empty until the account has been claimed.
    #[prost(string, tag = "1")]
    pub shannon_dest_address: ::prost::alloc::string::String,
    /// The hex-encoded address of the Morse account whose balance will be claimed.
    #[prost(string, tag = "2")]
    pub morse_src_address: ::prost::alloc::string::String,
    /// The unstaked upokt tokens (i.e. account balance) available for claiming.
    #[prost(message, optional, tag = "5")]
    pub unstaked_balance: ::core::option::Option<
        super::super::cosmos::base::v1beta1::Coin,
    >,
    /// The staked tokens associated with a supplier actor which corresponds to this account address.
    /// DEV_NOTE: A few contextual notes related to Morse:
    /// - A Supplier is called a Servicer or Node (not a full node) in Morse
    /// - All Validators are Servicers, not all servicers are Validators
    /// - Automatically, the top 100 staked Servicers are validator
    /// - This only accounts for servicer stake balance transition
    /// TODO_MAINNET(@Olshansk): Develop a strategy for bootstrapping validators in Shannon by working with the cosmos ecosystem
    #[prost(message, optional, tag = "6")]
    pub supplier_stake: ::core::option::Option<
        super::super::cosmos::base::v1beta1::Coin,
    >,
    /// The staked tokens associated with an application actor which corresponds to this account address.
    #[prost(message, optional, tag = "7")]
    pub application_stake: ::core::option::Option<
        super::super::cosmos::base::v1beta1::Coin,
    >,
    /// The Shannon height at which the account was claimed.
    /// This field is intended to remain empty until the account has been claimed.
    #[prost(int64, tag = "8")]
    pub claimed_at_height: i64,
}
impl ::prost::Name for MorseClaimableAccount {
    const NAME: &'static str = "MorseClaimableAccount";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MorseClaimableAccount".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MorseClaimableAccount".into()
    }
}
/// EventImportMorseClaimableAccounts is emitted when the MorseClaimableAccounts are created on-chain.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventImportMorseClaimableAccounts {
    /// The height (on Shannon) at which the MorseAccountState was created on-chain.
    #[prost(int64, tag = "1")]
    pub created_at_height: i64,
    /// The onchain computed sha256 hash of the entire MorseAccountState containing the MorseClaimableAccounts which were imported.
    #[prost(bytes = "vec", tag = "2")]
    pub morse_account_state_hash: ::prost::alloc::vec::Vec<u8>,
    /// Number of claimable accounts (EOAs) collected from Morse state export
    /// NOTE: Account balances include consolidated application and supplier actor stakes
    #[prost(uint64, tag = "3")]
    pub num_accounts: u64,
}
impl ::prost::Name for EventImportMorseClaimableAccounts {
    const NAME: &'static str = "EventImportMorseClaimableAccounts";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.EventImportMorseClaimableAccounts".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.EventImportMorseClaimableAccounts".into()
    }
}
/// EventMorseAccountClaimed is emitted when a MorseAccount is claimed on-chain.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventMorseAccountClaimed {
    /// The session end height (on Shannon) in which the claim was committed (i.e. claimed).
    #[prost(int64, tag = "1")]
    pub session_end_height: i64,
    /// The unstaked balance which was claimed.
    #[prost(message, optional, tag = "2")]
    pub claimed_balance: ::core::option::Option<
        super::super::cosmos::base::v1beta1::Coin,
    >,
    /// The bech32-encoded address of the Shannon account to which the claimed balance will be minted.
    #[prost(string, tag = "3")]
    pub shannon_dest_address: ::prost::alloc::string::String,
    /// The hex-encoded address of the Morse account whose balance will be claimed.
    #[prost(string, tag = "4")]
    pub morse_src_address: ::prost::alloc::string::String,
}
impl ::prost::Name for EventMorseAccountClaimed {
    const NAME: &'static str = "EventMorseAccountClaimed";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.EventMorseAccountClaimed".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.EventMorseAccountClaimed".into()
    }
}
/// EventMorseApplicationClaimed is emitted when a MorseAccount is claimed on-chain as a staked application.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventMorseApplicationClaimed {
    /// The session end height (on Shannon) in which the claim was committed (i.e. claimed).
    #[prost(int64, tag = "1")]
    pub session_end_height: i64,
    /// The unstaked balance which was claimed.
    #[prost(message, optional, tag = "2")]
    pub claimed_balance: ::core::option::Option<
        super::super::cosmos::base::v1beta1::Coin,
    >,
    /// The hex-encoded address of the Morse account whose balance will be claimed.
    #[prost(string, tag = "3")]
    pub morse_src_address: ::prost::alloc::string::String,
    /// The stake of the application which was staked as a result of the claim.
    #[prost(message, optional, tag = "4")]
    pub claimed_application_stake: ::core::option::Option<
        super::super::cosmos::base::v1beta1::Coin,
    >,
    /// The application which was staked as a result of the claim.
    /// This is equivalent to the amount it had staked on Morse.
    #[prost(message, optional, tag = "5")]
    pub application: ::core::option::Option<super::application::Application>,
}
impl ::prost::Name for EventMorseApplicationClaimed {
    const NAME: &'static str = "EventMorseApplicationClaimed";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.EventMorseApplicationClaimed".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.EventMorseApplicationClaimed".into()
    }
}
/// EventMorseSupplierClaimed is emitted when a MorseAccount is claimed on-chain as a staked Supplier.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventMorseSupplierClaimed {
    /// The session end height (on Shannon) in which the claim was committed (i.e. claimed).
    #[prost(int64, tag = "1")]
    pub session_end_height: i64,
    /// The unstaked balance which was claimed.
    #[prost(message, optional, tag = "2")]
    pub claimed_balance: ::core::option::Option<
        super::super::cosmos::base::v1beta1::Coin,
    >,
    /// The hex-encoded address of the Morse account whose balance will be claimed.
    #[prost(string, tag = "3")]
    pub morse_src_address: ::prost::alloc::string::String,
    /// The stake of the Supplier which was staked as a result of the claim.
    /// This will be equivalent to the amount it had staked on Morse.
    #[prost(message, optional, tag = "4")]
    pub claimed_supplier_stake: ::core::option::Option<
        super::super::cosmos::base::v1beta1::Coin,
    >,
    /// The Supplier which was staked as a result of the claim.
    #[prost(message, optional, tag = "5")]
    pub supplier: ::core::option::Option<super::shared::Supplier>,
}
impl ::prost::Name for EventMorseSupplierClaimed {
    const NAME: &'static str = "EventMorseSupplierClaimed";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.EventMorseSupplierClaimed".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.EventMorseSupplierClaimed".into()
    }
}
/// Params defines the parameters for the module.
///
/// Next free index: 3
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Params {
    /// waive_morse_claim_gas_fees is a feature flag used to enable/disable the waiving of gas fees for txs that:
    /// - Contain exactly one secp256k1 signer
    /// - Contain at least one Morse account/actor claim messages
    /// - Do not contain any other messages other than Morse account/actor claim messages
    #[prost(bool, tag = "1")]
    pub waive_morse_claim_gas_fees: bool,
    /// allow_morse_account_import_overwrite is a feature flag which is used to enable/disable
    /// the re-importing of Morse claimable accounts by the authority.
    /// Such a re-import will:
    /// - Ignore (i.e. leave) ALL claimed destination Shannon accounts/actors
    /// - Delete ALL existing onchain MorseClaimableAccounts
    /// - Import the new set of MorseClaimableAccounts from the provided MsgImportMorseClaimableAccounts
    /// This is useful for testing purposes, but should be disabled in production.
    #[prost(bool, tag = "2")]
    pub allow_morse_account_import_overwrite: bool,
}
impl ::prost::Name for Params {
    const NAME: &'static str = "Params";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.Params".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.Params".into()
    }
}
/// GenesisState defines the migration module's genesis state.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenesisState {
    /// params defines all the parameters of the module.
    #[prost(message, optional, tag = "1")]
    pub params: ::core::option::Option<Params>,
    #[prost(message, repeated, tag = "2")]
    pub morse_claimable_account_list: ::prost::alloc::vec::Vec<MorseClaimableAccount>,
}
impl ::prost::Name for GenesisState {
    const NAME: &'static str = "GenesisState";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.GenesisState".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.GenesisState".into()
    }
}
/// MorseStateExport is the data structure that is serialized and output when running:
///   $ pocket utils export-genesis-for-reset ...
///
/// Ref: <https://editor.swagger.io/?url=https://raw.githubusercontent.com/pokt-network/pocket-core/staging/doc/specs/rpc-spec.yaml#operations-query-post_query_state>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MorseStateExport {
    /// app_hash is the Morse tendermint state hash.
    #[prost(string, tag = "1")]
    pub app_hash: ::prost::alloc::string::String,
    /// app_state is the entire Morse tendermint application state.
    #[prost(message, optional, tag = "2")]
    pub app_state: ::core::option::Option<MorseTendermintAppState>,
}
impl ::prost::Name for MorseStateExport {
    const NAME: &'static str = "MorseStateExport";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MorseStateExport".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MorseStateExport".into()
    }
}
/// MorseTendermintAppState is the tendermint application state for the Morse tendermint
/// application; not to be confused with the pokt protocol actor.
/// It is constructed in Morse via `PocketCoreApp#ExportAppState()`.
///
/// See: <https://github.com/pokt-network/pocket-core/blob/5fa61920aa9d45ca6bf9e01e863134e242c95fa7/app/pocket.go#L142>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MorseTendermintAppState {
    #[prost(message, optional, tag = "1")]
    pub application: ::core::option::Option<MorseApplications>,
    #[prost(message, optional, tag = "2")]
    pub auth: ::core::option::Option<MorseAuth>,
    #[prost(message, optional, tag = "3")]
    pub pos: ::core::option::Option<MorsePos>,
}
impl ::prost::Name for MorseTendermintAppState {
    const NAME: &'static str = "MorseTendermintAppState";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MorseTendermintAppState".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MorseTendermintAppState".into()
    }
}
/// A wrapper around the list of MorseApplications, necessary in order to conform to the Morse genesis structure.
/// It encapsulates the minimum information required to import Morse applications.
///
/// See: <https://github.com/pokt-network/pocket-core/blob/staging/x/apps/types/genesis.go#L4>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MorseApplications {
    #[prost(message, repeated, tag = "1")]
    pub applications: ::prost::alloc::vec::Vec<MorseApplication>,
}
impl ::prost::Name for MorseApplications {
    const NAME: &'static str = "MorseApplications";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MorseApplications".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MorseApplications".into()
    }
}
/// A wrapper around a list of MorseAuthAccount.
/// It encapsulates the minimum information required to import Morse accounts.
///
/// See: <https://github.com/pokt-network/pocket-core/blob/staging/x/auth/types/genesis.go#L9>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MorseAuth {
    #[prost(message, repeated, tag = "1")]
    pub accounts: ::prost::alloc::vec::Vec<MorseAuthAccount>,
}
impl ::prost::Name for MorseAuth {
    const NAME: &'static str = "MorseAuth";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MorseAuth".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MorseAuth".into()
    }
}
/// MorseAuthAccount:
/// * Wraps MorseAuthAccount information to conform to Morse genesis structure
/// * Can represent EITHER an externally owned account OR a module account
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MorseAuthAccount {
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    /// value is a EITHER a JSON-encoded MorseAccount or a MorseModuleAccount.
    #[prost(bytes = "vec", tag = "3")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for MorseAuthAccount {
    const NAME: &'static str = "MorseAuthAccount";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MorseAuthAccount".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MorseAuthAccount".into()
    }
}
/// A wrapper around the list of Morse suppliers (aka "validators", "nodes", of "servicers").
/// It is necessary to conform to the Morse genesis structure.
///
/// See: <https://github.com/pokt-network/pocket-core/blob/staging/x/nodes/types/genesis.go#L8>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MorsePos {
    #[prost(message, repeated, tag = "1")]
    pub validators: ::prost::alloc::vec::Vec<MorseValidator>,
}
impl ::prost::Name for MorsePos {
    const NAME: &'static str = "MorsePos";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MorsePos".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MorsePos".into()
    }
}
/// MorseApplication is a subset of the Morse ProtoApplication type.
/// It encapsulates the minimum information required to import Morse applications.
///
/// See: <https://github.com/pokt-network/pocket-core/blob/staging/proto/x/apps/apps.proto#L16>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MorseApplication {
    /// Address is a binary representation of the address corresponding
    /// to a Morse application's ed25519 public key.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// PublicKey is the binary representation of a Morse application's ed25519 public key.
    #[prost(bytes = "vec", tag = "2")]
    pub public_key: ::prost::alloc::vec::Vec<u8>,
    /// TODO_MAINNET_MIGRATION(@Olshansk):  Should status and/or jailed be considered during the migration, and if so, how?
    #[prost(bool, tag = "3")]
    pub jailed: bool,
    #[prost(int32, tag = "4")]
    pub status: i32,
    /// The string representation of the BigInt amount of upokt.
    #[prost(string, tag = "6")]
    pub staked_tokens: ::prost::alloc::string::String,
}
impl ::prost::Name for MorseApplication {
    const NAME: &'static str = "MorseApplication";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MorseApplication".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MorseApplication".into()
    }
}
/// MorseValidator is a subset of the Morse ProtoValidator type.
/// It encapsulates the minimum information required to import Morse suppliers (aka "servicers" or "validators").
///
/// See: <https://github.com/pokt-network/pocket-core/blob/staging/proto/x/pos/types.proto#L16>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MorseValidator {
    /// A binary representation of the address corresponding to a Morse application's ed25519 public key.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// The binary representation of a Morse application's ed25519 public key.
    #[prost(bytes = "vec", tag = "2")]
    pub public_key: ::prost::alloc::vec::Vec<u8>,
    /// TODO_MAINNET_MIGRATION(@Olshansk):  Should status and/or jailed be considered during the migration, and if so, how?
    #[prost(bool, tag = "3")]
    pub jailed: bool,
    #[prost(int32, tag = "4")]
    pub status: i32,
    /// The string representation of the BigInt amount of upokt.
    #[prost(string, tag = "7")]
    pub staked_tokens: ::prost::alloc::string::String,
}
impl ::prost::Name for MorseValidator {
    const NAME: &'static str = "MorseValidator";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MorseValidator".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MorseValidator".into()
    }
}
/// MorseAccount is an analog of the Morse ProtoBaseAccount type.
/// It encapsulates the minimum information required to import accounts.
///
/// See: <https://github.com/pokt-network/pocket-core/blob/staging/proto/x/auth/auth.proto#L14.>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MorseAccount {
    /// A hex-encoded representation of the address corresponding to a Morse application's ed25519 public key.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// The ed25519 public key of the account.
    #[prost(message, optional, tag = "2")]
    pub pub_key: ::core::option::Option<MorsePublicKey>,
    /// The account balance; this does not include any actor stakes.
    #[prost(message, repeated, tag = "3")]
    pub coins: ::prost::alloc::vec::Vec<super::super::cosmos::base::v1beta1::Coin>,
}
impl ::prost::Name for MorseAccount {
    const NAME: &'static str = "MorseAccount";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MorseAccount".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MorseAccount".into()
    }
}
/// MorsePublicKey is required to conform to the encoding of the Morse state export.
/// NB: All Morse account public keys will be ed25519 keys by definition.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MorsePublicKey {
    #[prost(bytes = "vec", tag = "2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for MorsePublicKey {
    const NAME: &'static str = "MorsePublicKey";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MorsePublicKey".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MorsePublicKey".into()
    }
}
/// MorseModuleAccount is the module account type for Morse, it wraps a MorseAccount
/// and has a unique name, which is used instead of the address.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MorseModuleAccount {
    /// DEV_NOTE: the JSON tag is intentionally cased contrary to convention to match the real-world Morse state export.
    #[prost(message, optional, tag = "1")]
    pub base_account: ::core::option::Option<MorseAccount>,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for MorseModuleAccount {
    const NAME: &'static str = "MorseModuleAccount";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MorseModuleAccount".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MorseModuleAccount".into()
    }
}
/// QueryParamsRequest is request type for the Query/Params RPC method.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryParamsRequest {}
impl ::prost::Name for QueryParamsRequest {
    const NAME: &'static str = "QueryParamsRequest";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.QueryParamsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.QueryParamsRequest".into()
    }
}
/// QueryParamsResponse is response type for the Query/Params RPC method.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryParamsResponse {
    /// params holds all the parameters of this module.
    #[prost(message, optional, tag = "1")]
    pub params: ::core::option::Option<Params>,
}
impl ::prost::Name for QueryParamsResponse {
    const NAME: &'static str = "QueryParamsResponse";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.QueryParamsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.QueryParamsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryMorseClaimableAccountRequest {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryMorseClaimableAccountRequest {
    const NAME: &'static str = "QueryMorseClaimableAccountRequest";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.QueryMorseClaimableAccountRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.QueryMorseClaimableAccountRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryMorseClaimableAccountResponse {
    #[prost(message, optional, tag = "1")]
    pub morse_claimable_account: ::core::option::Option<MorseClaimableAccount>,
}
impl ::prost::Name for QueryMorseClaimableAccountResponse {
    const NAME: &'static str = "QueryMorseClaimableAccountResponse";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.QueryMorseClaimableAccountResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.QueryMorseClaimableAccountResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAllMorseClaimableAccountRequest {
    #[prost(message, optional, tag = "1")]
    pub pagination: ::core::option::Option<
        super::super::cosmos::base::query::v1beta1::PageRequest,
    >,
}
impl ::prost::Name for QueryAllMorseClaimableAccountRequest {
    const NAME: &'static str = "QueryAllMorseClaimableAccountRequest";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.QueryAllMorseClaimableAccountRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.QueryAllMorseClaimableAccountRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAllMorseClaimableAccountResponse {
    #[prost(message, repeated, tag = "1")]
    pub morse_claimable_account: ::prost::alloc::vec::Vec<MorseClaimableAccount>,
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        super::super::cosmos::base::query::v1beta1::PageResponse,
    >,
}
impl ::prost::Name for QueryAllMorseClaimableAccountResponse {
    const NAME: &'static str = "QueryAllMorseClaimableAccountResponse";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.QueryAllMorseClaimableAccountResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.QueryAllMorseClaimableAccountResponse".into()
    }
}
/// Generated client implementations.
pub mod query_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Query defines the gRPC querier service.
    #[derive(Debug, Clone)]
    pub struct QueryClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl QueryClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> QueryClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> QueryClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            QueryClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Parameters queries the parameters of the module.
        pub async fn params(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryParamsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryParamsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pocket.migration.Query/Params",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pocket.migration.Query", "Params"));
            self.inner.unary(req, path, codec).await
        }
        /// Queries a list of MorseClaimableAccount items.
        pub async fn morse_claimable_account(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryMorseClaimableAccountRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryMorseClaimableAccountResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pocket.migration.Query/MorseClaimableAccount",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("pocket.migration.Query", "MorseClaimableAccount"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn morse_claimable_account_all(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryAllMorseClaimableAccountRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryAllMorseClaimableAccountResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pocket.migration.Query/MorseClaimableAccountAll",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("pocket.migration.Query", "MorseClaimableAccountAll"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// MsgUpdateParams is the Msg/UpdateParams request type.
///
/// Next free index: 3
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUpdateParams {
    /// authority is the address that controls the module (defaults to x/gov unless overwritten).
    #[prost(string, tag = "1")]
    pub authority: ::prost::alloc::string::String,
    /// NOTE: All parameters must be supplied.
    #[prost(message, optional, tag = "2")]
    pub params: ::core::option::Option<Params>,
}
impl ::prost::Name for MsgUpdateParams {
    const NAME: &'static str = "MsgUpdateParams";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MsgUpdateParams".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MsgUpdateParams".into()
    }
}
/// MsgUpdateParamsResponse defines the response structure for executing a
/// MsgUpdateParams message.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgUpdateParamsResponse {}
impl ::prost::Name for MsgUpdateParamsResponse {
    const NAME: &'static str = "MsgUpdateParamsResponse";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MsgUpdateParamsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MsgUpdateParamsResponse".into()
    }
}
/// MsgImportMorseClaimableAccounts is used to create the on-chain MorseClaimableAccounts ONLY AND EXACTLY ONCE (per network / re-genesis).
///
/// Next free index: 4
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgImportMorseClaimableAccounts {
    /// authority is the address that controls the module (defaults to x/gov unless overwritten).
    #[prost(string, tag = "1")]
    pub authority: ::prost::alloc::string::String,
    /// the account state derived from the Morse state export and the `pocketd tx migration collect-morse-accounts` command.
    #[prost(message, optional, tag = "2")]
    pub morse_account_state: ::core::option::Option<MorseAccountState>,
    /// Additional documentation:
    /// - pocket util export-genesis-for-migration --help
    /// - pocketd tx migration collect-morse-accounts --help
    #[prost(bytes = "vec", tag = "3")]
    pub morse_account_state_hash: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for MsgImportMorseClaimableAccounts {
    const NAME: &'static str = "MsgImportMorseClaimableAccounts";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MsgImportMorseClaimableAccounts".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MsgImportMorseClaimableAccounts".into()
    }
}
/// MsgImportMorseClaimableAccountsResponse is returned from MsgImportMorseClaimableAccounts.
/// It indicates the canonical hash of the imported MorseAccountState, and the number of claimable accounts which were imported.
///
/// Next free index: 3
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgImportMorseClaimableAccountsResponse {
    /// On-chain computed sha256 hash of the morse_account_state provided in the corresponding MsgCreateMorseAccountState.
    #[prost(bytes = "vec", tag = "1")]
    pub state_hash: ::prost::alloc::vec::Vec<u8>,
    /// Number of claimable accounts (EOAs) collected from Morse state export.
    #[prost(uint64, tag = "2")]
    pub num_accounts: u64,
}
impl ::prost::Name for MsgImportMorseClaimableAccountsResponse {
    const NAME: &'static str = "MsgImportMorseClaimableAccountsResponse";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MsgImportMorseClaimableAccountsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MsgImportMorseClaimableAccountsResponse".into()
    }
}
/// MsgClaimMorseAccount is used to execute a claim (one-time minting of tokens on Shannon),
/// of the balance of the given Morse account, according to the on-chain MorseClaimableAccounts,
/// to the balance of the given Shannon account.
///
/// NOTE:
/// - The Shannon account specified must be the message signer
/// - Authz grants MAY be used to delegate claiming authority to other Shannon accounts
///
/// Next free index: 6
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgClaimMorseAccount {
    /// The bech32-encoded address of the Shannon account which is signing for this message.
    /// This account is liable for any fees incurred by violating the constraints of Morse
    /// account/actor claim message fee waiving; the tx contains ONE OR MORE Morse account/actor
    /// claim messages AND has EXACTLY ONE signer.
    #[prost(string, tag = "4")]
    pub shannon_signing_address: ::prost::alloc::string::String,
    /// The bech32-encoded address of the Shannon account to which the claimed balance will be minted.
    #[prost(string, tag = "1")]
    pub shannon_dest_address: ::prost::alloc::string::String,
    /// The ed25519 public key of the morse account with morse_src_address.
    #[prost(bytes = "vec", tag = "5")]
    pub morse_public_key: ::prost::alloc::vec::Vec<u8>,
    /// The hex-encoded signature, by the Morse account, of this message (where this field is nil).
    /// I.e.: morse_signature = private_key.sign(marshal(MsgClaimMorseAccount{morse_signature: nil, ...}))
    #[prost(bytes = "vec", tag = "3")]
    pub morse_signature: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for MsgClaimMorseAccount {
    const NAME: &'static str = "MsgClaimMorseAccount";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MsgClaimMorseAccount".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MsgClaimMorseAccount".into()
    }
}
/// MsgClaimMorseAccountResponse is returned from MsgClaimMorseAccount.
/// It indicates the morse_src_address of the account which was claimed, the total
/// balance claimed, and the height at which the claim was committed.
///
/// Next free index: 4
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgClaimMorseAccountResponse {
    /// The hex-encoded address of the Morse account whose balance will be claimed.
    /// E.g.: 00f9900606fa3d5c9179fc0c8513078a53a2073e
    #[prost(string, tag = "1")]
    pub morse_src_address: ::prost::alloc::string::String,
    /// The balance which was claimed.
    #[prost(message, optional, tag = "2")]
    pub claimed_balance: ::core::option::Option<
        super::super::cosmos::base::v1beta1::Coin,
    >,
    /// The session end height (on Shannon) in which the claim was committed (i.e. claimed).
    #[prost(int64, tag = "3")]
    pub session_end_height: i64,
}
impl ::prost::Name for MsgClaimMorseAccountResponse {
    const NAME: &'static str = "MsgClaimMorseAccountResponse";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MsgClaimMorseAccountResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MsgClaimMorseAccountResponse".into()
    }
}
/// MsgClaimMorseApplication is used to execute a claim (one-time minting of tokens on Shannon),
/// of the total tokens owned by the given Morse account, according to the on-chain MorseClaimableAccounts,
/// to the balance of the given Shannon account, followed by staking that Shannon account as an application
/// for the given service_config and the same stake amount as on Morse.
///
/// Next free index: 7
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgClaimMorseApplication {
    /// The bech32-encoded address of the Shannon account which is signing for this message.
    /// This account is liable for any fees incurred by violating the constraints of Morse
    /// account/actor claim message fee waiving; the tx contains ONE OR MORE Morse account/actor
    /// claim messages AND has EXACTLY ONE signer.
    #[prost(string, tag = "5")]
    pub shannon_signing_address: ::prost::alloc::string::String,
    /// The bech32-encoded address of the Shannon account to which the claimed tokens
    /// will be minted and from which the application will be staked.
    #[prost(string, tag = "1")]
    pub shannon_dest_address: ::prost::alloc::string::String,
    /// The ed25519 public key of the morse account with morse_src_address.
    #[prost(bytes = "vec", tag = "6")]
    pub morse_public_key: ::prost::alloc::vec::Vec<u8>,
    /// The hex-encoded signature, by the Morse account, of this message (where this field is nil).
    /// I.e.: morse_signature = private_key.sign(marshal(MsgClaimMorseAccount{morse_signature: nil, ...}))
    #[prost(bytes = "vec", tag = "3")]
    pub morse_signature: ::prost::alloc::vec::Vec<u8>,
    /// The services this application is staked to request service for.
    /// NOTE: This is not a repeated field, as in MsgStakeApplication,
    /// because an application can only be staked for one service.
    #[prost(message, optional, tag = "4")]
    pub service_config: ::core::option::Option<super::shared::ApplicationServiceConfig>,
}
impl ::prost::Name for MsgClaimMorseApplication {
    const NAME: &'static str = "MsgClaimMorseApplication";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MsgClaimMorseApplication".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MsgClaimMorseApplication".into()
    }
}
/// MsgClaimMorseApplicationResponse is returned from MsgClaimMorseApplication.
/// It indicates the morse_src_address of the account which was claimed, the unstaked
/// balance claimed, the application stake, and the height at which the claim was committed.
///
/// Next free index: 6
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgClaimMorseApplicationResponse {
    /// The hex-encoded address of the Morse account whose balance will be claimed.
    #[prost(string, tag = "1")]
    pub morse_src_address: ::prost::alloc::string::String,
    /// The unstaked balance which was claimed.
    #[prost(message, optional, tag = "2")]
    pub claimed_balance: ::core::option::Option<
        super::super::cosmos::base::v1beta1::Coin,
    >,
    /// The stake of the application which was staked as a result of the claim.
    /// If the application was already staked, this amount does not include the initial stake (i.e. only the portion which was "claimed").
    #[prost(message, optional, tag = "3")]
    pub claimed_application_stake: ::core::option::Option<
        super::super::cosmos::base::v1beta1::Coin,
    >,
    /// The session end height (on Shannon) in which the claim was committed (i.e. claimed).
    #[prost(int64, tag = "4")]
    pub session_end_height: i64,
    /// The application which was staked as a result of the claim.
    #[prost(message, optional, tag = "5")]
    pub application: ::core::option::Option<super::application::Application>,
}
impl ::prost::Name for MsgClaimMorseApplicationResponse {
    const NAME: &'static str = "MsgClaimMorseApplicationResponse";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MsgClaimMorseApplicationResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MsgClaimMorseApplicationResponse".into()
    }
}
/// MsgClaimMorseSupplier is used to:
/// - Execute a one-time minting of tokens on Shannon based on tokens owned by the given Morse account
/// - Use the on-chain MorseClaimableAccounts for verification
/// - Credit the minted tokens to the balance of the given Shannon account
/// - Automatically stake that Shannon account as a supplier
///
/// NOTE: The supplier module's staking fee parameter (at the time of claiming) is deducted from the
/// claimed balance.
///
/// Next free index: 8
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgClaimMorseSupplier {
    /// The bech32-encoded address of the Shannon account which is signing for this message.
    /// This account is liable for any fees incurred by violating the constraints of Morse
    /// account/actor claim message fee waiving; the tx contains ONE OR MORE Morse account/actor
    /// claim messages AND has EXACTLY ONE signer.
    #[prost(string, tag = "6")]
    pub shannon_signing_address: ::prost::alloc::string::String,
    /// The bech32-encoded address of the Shannon account to which the claimed tokens
    /// will be minted and which become the supplier owner.
    /// See: <https://dev.poktroll.com/operate/configs/supplier_staking_config#staking-types.>
    #[prost(string, tag = "1")]
    pub shannon_owner_address: ::prost::alloc::string::String,
    /// The bech32-encoded address of the Shannon account to which will become the supplier operator.
    /// If empty, the shannon_owner_address will be used.
    /// See: <https://dev.poktroll.com/operate/configs/supplier_staking_config#staking-types.>
    #[prost(string, tag = "2")]
    pub shannon_operator_address: ::prost::alloc::string::String,
    /// The ed25519 public key of the morse account with morse_src_address.
    #[prost(bytes = "vec", tag = "7")]
    pub morse_public_key: ::prost::alloc::vec::Vec<u8>,
    /// TODO_MAINNET(@bryanchriswhite, #1126): Rename to `morse_src_owner_signature`.
    #[prost(bytes = "vec", tag = "4")]
    pub morse_signature: ::prost::alloc::vec::Vec<u8>,
    /// The services this supplier is staked to provide service for.
    #[prost(message, repeated, tag = "5")]
    pub services: ::prost::alloc::vec::Vec<super::shared::SupplierServiceConfig>,
}
impl ::prost::Name for MsgClaimMorseSupplier {
    const NAME: &'static str = "MsgClaimMorseSupplier";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MsgClaimMorseSupplier".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MsgClaimMorseSupplier".into()
    }
}
/// MsgClaimMorseSupplierResponse is returned from MsgClaimMorseSupplier.
/// It indicates:
/// - The morse_src_address of the claimed account
/// - The unstaked balance claimed
/// - The session end height in which the claim was committed
/// - The staked supplier
///
/// Next free index: 6
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgClaimMorseSupplierResponse {
    /// The hex-encoded address of the Morse account whose balance was claimed.
    /// E.g.: 00f9900606fa3d5c9179fc0c8513078a53a2073e
    #[prost(string, tag = "1")]
    pub morse_src_address: ::prost::alloc::string::String,
    /// The unstaked balance which was claimed.
    #[prost(message, optional, tag = "2")]
    pub claimed_balance: ::core::option::Option<
        super::super::cosmos::base::v1beta1::Coin,
    >,
    #[prost(message, optional, tag = "3")]
    pub claimed_supplier_stake: ::core::option::Option<
        super::super::cosmos::base::v1beta1::Coin,
    >,
    /// The session end height (on Shannon) in which the claim was committed (i.e. claimed).
    #[prost(int64, tag = "4")]
    pub session_end_height: i64,
    /// The supplier which was staked as a result of the claim.
    #[prost(message, optional, tag = "5")]
    pub supplier: ::core::option::Option<super::shared::Supplier>,
}
impl ::prost::Name for MsgClaimMorseSupplierResponse {
    const NAME: &'static str = "MsgClaimMorseSupplierResponse";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MsgClaimMorseSupplierResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MsgClaimMorseSupplierResponse".into()
    }
}
/// MsgRecoverMorseAccount is used to:
/// - Execute a one-time minting of tokens on Shannon based on tokens owned by the given Morse account
/// - Credit the minted tokens to the balance of the given Shannon account
/// - Migrate unclaimable staked and liquid Morse tokens as liquid Shannon tokens
/// It MAY ONLY be executed by the authority, and is ONLY intended for use
/// on accounts with invalid addresses and/or known lost private keys.
///
/// Next free index: 4
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgRecoverMorseAccount {
    /// The bech32-encoded address of the migration module authority account ("gov" module address by default).
    /// ONLY the authority, or its delegates, MAY recover Morse recoverable accounts.
    #[prost(string, tag = "1")]
    pub authority: ::prost::alloc::string::String,
    /// The bech32-encoded address of the Shannon account to which the Morse account's stake(s) and/or
    /// balance(s) will be minted (recovered) as liquid Shannon tokens.
    #[prost(string, tag = "2")]
    pub shannon_dest_address: ::prost::alloc::string::String,
    /// EITHER:
    /// - The hex-encoded address of the recoverable Morse account whose stake(s) and/or balance(s) will be recovered.
    ///    This address MAY be invalid but NEVER empty.
    ///    E.g.: 00f9900606fa3d5c9179fc0c8513078a53a2073e
    /// - The name of a Morse module account whose balance will be recovered.
    ///    E.g. "dao" or "fee-collector"
    #[prost(string, tag = "3")]
    pub morse_src_address: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgRecoverMorseAccount {
    const NAME: &'static str = "MsgRecoverMorseAccount";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MsgRecoverMorseAccount".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MsgRecoverMorseAccount".into()
    }
}
/// MsgRecoverMorseAccountResponse is returned from MsgRecoverMorseAccount.
/// It indicates:
/// - The morse_src_address of the recovered account
/// - The sum of any actor stakes and unstaked balance recovered
/// - The session end height in which the recovery was committed
///
/// Next free index: 5
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgRecoverMorseAccountResponse {
    /// EITHER:
    /// - The hex-encoded address of the Morse account whose stake(s) and/or balances were recovered.
    ///    This address MAY be invalid but NEVER empty.
    ///    E.g.: 00f9900606fa3d5c9179fc0c8513078a53a2073e
    /// - The name of a Morse module account whose balance was recovered.
    ///    E.g. "dao" or "fee-collector"
    #[prost(string, tag = "1")]
    pub morse_src_address: ::prost::alloc::string::String,
    /// The sum of any unstaked and staked balances which were recovered.
    #[prost(message, optional, tag = "2")]
    pub recovered_balance: ::core::option::Option<
        super::super::cosmos::base::v1beta1::Coin,
    >,
    /// The session end height (on Shannon) in which the recovery was committed (i.e. recovered).
    #[prost(int64, tag = "3")]
    pub session_end_height: i64,
    /// The bech32-encoded address of the Shannon account to which the Morse account's stake(s) and/or
    /// balance(s) were recovered.
    #[prost(string, tag = "4")]
    pub shannon_dest_address: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgRecoverMorseAccountResponse {
    const NAME: &'static str = "MsgRecoverMorseAccountResponse";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MsgRecoverMorseAccountResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MsgRecoverMorseAccountResponse".into()
    }
}
/// Generated client implementations.
pub mod msg_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Msg defines the Msg service.
    #[derive(Debug, Clone)]
    pub struct MsgClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl MsgClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> MsgClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MsgClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            MsgClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// UpdateParams defines a (governance) operation for updating the module
        /// parameters. The authority defaults to the x/gov module account.
        pub async fn update_params(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgUpdateParams>,
        ) -> std::result::Result<
            tonic::Response<super::MsgUpdateParamsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pocket.migration.Msg/UpdateParams",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pocket.migration.Msg", "UpdateParams"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn import_morse_claimable_accounts(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgImportMorseClaimableAccounts>,
        ) -> std::result::Result<
            tonic::Response<super::MsgImportMorseClaimableAccountsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pocket.migration.Msg/ImportMorseClaimableAccounts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "pocket.migration.Msg",
                        "ImportMorseClaimableAccounts",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn claim_morse_account(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgClaimMorseAccount>,
        ) -> std::result::Result<
            tonic::Response<super::MsgClaimMorseAccountResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pocket.migration.Msg/ClaimMorseAccount",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pocket.migration.Msg", "ClaimMorseAccount"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn claim_morse_application(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgClaimMorseApplication>,
        ) -> std::result::Result<
            tonic::Response<super::MsgClaimMorseApplicationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pocket.migration.Msg/ClaimMorseApplication",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("pocket.migration.Msg", "ClaimMorseApplication"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn claim_morse_supplier(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgClaimMorseSupplier>,
        ) -> std::result::Result<
            tonic::Response<super::MsgClaimMorseSupplierResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pocket.migration.Msg/ClaimMorseSupplier",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pocket.migration.Msg", "ClaimMorseSupplier"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn recover_morse_account(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgRecoverMorseAccount>,
        ) -> std::result::Result<
            tonic::Response<super::MsgRecoverMorseAccountResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pocket.migration.Msg/RecoverMorseAccount",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pocket.migration.Msg", "RecoverMorseAccount"));
            self.inner.unary(req, path, codec).await
        }
    }
}
