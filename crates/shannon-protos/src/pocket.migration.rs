// This file is @generated by prost-build.
/// MorseAccountState
/// - Onchain representation of all account state to be migrated from Morse
/// - NEVER persisted onchain
/// - Dependency of the MsgImportMorseClaimableAccount handler
/// - Main purpose: exposes #GetHash() for verifying integrity of all MorseClaimableAccounts
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MorseAccountState {
    #[prost(message, repeated, tag = "2")]
    pub accounts: ::prost::alloc::vec::Vec<MorseClaimableAccount>,
}
impl ::prost::Name for MorseAccountState {
    const NAME: &'static str = "MorseAccountState";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MorseAccountState".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MorseAccountState".into()
    }
}
/// MorseClaimableAccount
/// - Onchain (persisted) representation of a Morse account claimable as part of Morse -> Shannon migration
/// - Created during MorseAccountState import (see: MsgImportMorseClaimableAccount)
/// - Created ONLY ONCE and NEVER deleted (per morse_src_address per network / re-genesis),
///    unless the allow_morse_account_import_overwrite migration param is enabled
/// - Updated ONLY ONCE, when claimed (per morse_src_address per network / re-genesis)
///
/// Next free index: 11
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MorseClaimableAccount {
    /// bech32-encoded address of the Shannon account to mint claimed balance
    /// Intended to remain empty until the account is claimed
    #[prost(string, tag = "1")]
    pub shannon_dest_address: ::prost::alloc::string::String,
    /// Hex-encoded address of the Morse account whose balance will be claimed.
    /// If this MorseClaimableAccount represents a Morse node/supplier:
    ///    - Morse non-custodial (i.e. operator) address.
    ///    - If morse_output_address is not set, this is the custodial address.
    ///    - See 'pocket nodes --help' for more information. Note that this refers to the Morse CLI.
    #[prost(string, tag = "2")]
    pub morse_src_address: ::prost::alloc::string::String,
    /// Unstaked upokt tokens (account balance) available for claiming
    #[prost(message, optional, tag = "5")]
    pub unstaked_balance: ::core::option::Option<
        super::super::cosmos::base::v1beta1::Coin,
    >,
    /// Staked tokens for supplier actor corresponding to this account address
    /// DEV_NOTE: Context for Morse:
    /// - Supplier = Servicer or Node (not a full node) in Morse
    /// - All Validators are Servicers; not all Servicers are Validators
    /// - Top 100 staked Servicers are validators (automatic)
    /// - Only accounts for servicer stake balance transition
    /// TODO_MAINNET(@Olshansk): Develop strategy for bootstrapping validators in Shannon with cosmos ecosystem
    #[prost(message, optional, tag = "6")]
    pub supplier_stake: ::core::option::Option<
        super::super::cosmos::base::v1beta1::Coin,
    >,
    /// Staked tokens for application actor corresponding to this account address
    #[prost(message, optional, tag = "7")]
    pub application_stake: ::core::option::Option<
        super::super::cosmos::base::v1beta1::Coin,
    >,
    /// Shannon height at which the account was claimed
    /// Intended to remain empty until the account is claimed
    #[prost(int64, tag = "8")]
    pub claimed_at_height: i64,
    /// ONLY applicable to Morse node/supplier accounts.
    /// Hex-encoded address of the Morse output account/wallet associated with the Morse node/supplier.
    /// - E.g.: 00f9900606fa3d5c9179fc0c8513078a53a2073e
    /// - Morse custodial (i.e. owner) address, which owns the staked tokens of the operator.
    ///    See 'pocket nodes --help' for more information. Note that this refers to the Morse CLI.
    #[prost(string, tag = "9")]
    pub morse_output_address: ::prost::alloc::string::String,
    /// The ISO 8601 UTC timestamp after which the Morse node/supplier unbonding period will have elapsed.
    /// It reflects the "unbonding completion time" of the Morse node/supplier, but is called "unstaking time" to comply with necessary Morse data structures.
    #[prost(message, optional, tag = "10")]
    pub unstaking_time: ::core::option::Option<::prost_types::Timestamp>,
}
impl ::prost::Name for MorseClaimableAccount {
    const NAME: &'static str = "MorseClaimableAccount";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MorseClaimableAccount".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MorseClaimableAccount".into()
    }
}
/// MorseSupplierClaimSignerType
/// - Enum for Morse supplier claim signer type
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum MorseSupplierClaimSignerType {
    /// Unspecified signer type
    Unspecified = 0,
    /// signer === addr === operator === owner
    /// Custodial signer type
    /// - The Morse node address is NOT EMPTY (i.e. operator)
    /// - The Morse output address is EMPTY (i.e. owner)
    /// - Implies that the operator and owner are THE SAME offchain identity
    CustodialSignedByNodeAddr = 1,
    /// signer === operator === addr && owner !== operator
    /// Non-custodial signer type
    /// - The Morse node address is NOT EMPTY (i.e. operator)
    /// - The Morse output address is NOT EMPTY (i.e. owner)
    /// - Implies that the operator and owner are MOST LIKELY DIFFERENT offchain identities
    /// - The operator is the one signing the supplier claim
    NonCustodialSignedByNodeAddr = 2,
    /// signer === owner && owner !== addr
    /// Owner non-custodial signer type
    /// - The Morse node address is EMPTY (i.e. operator)
    /// - The Morse output address is NOT EMPTY (i.e. owner)
    /// - Implies that the operator and owner are MOST LIKELY different offchain identities
    /// - The owner is the one signing the supplier claim
    NonCustodialSignedByOwner = 3,
}
impl MorseSupplierClaimSignerType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "MORSE_SUPPLIER_CLAIM_SIGNER_TYPE_UNSPECIFIED",
            Self::CustodialSignedByNodeAddr => {
                "MORSE_SUPPLIER_CLAIM_SIGNER_TYPE_CUSTODIAL_SIGNED_BY_NODE_ADDR"
            }
            Self::NonCustodialSignedByNodeAddr => {
                "MORSE_SUPPLIER_CLAIM_SIGNER_TYPE_NON_CUSTODIAL_SIGNED_BY_NODE_ADDR"
            }
            Self::NonCustodialSignedByOwner => {
                "MORSE_SUPPLIER_CLAIM_SIGNER_TYPE_NON_CUSTODIAL_SIGNED_BY_OWNER"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "MORSE_SUPPLIER_CLAIM_SIGNER_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "MORSE_SUPPLIER_CLAIM_SIGNER_TYPE_CUSTODIAL_SIGNED_BY_NODE_ADDR" => {
                Some(Self::CustodialSignedByNodeAddr)
            }
            "MORSE_SUPPLIER_CLAIM_SIGNER_TYPE_NON_CUSTODIAL_SIGNED_BY_NODE_ADDR" => {
                Some(Self::NonCustodialSignedByNodeAddr)
            }
            "MORSE_SUPPLIER_CLAIM_SIGNER_TYPE_NON_CUSTODIAL_SIGNED_BY_OWNER" => {
                Some(Self::NonCustodialSignedByOwner)
            }
            _ => None,
        }
    }
}
/// EventImportMorseClaimableAccounts
/// - Emitted when MorseClaimableAccounts are created on-chain
/// - Represents import event for Morse claimable accounts
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventImportMorseClaimableAccounts {
    /// Shannon height at which MorseAccountState was created on-chain
    #[prost(int64, tag = "1")]
    pub created_at_height: i64,
    /// On-chain computed sha256 hash of the MorseAccountState
    /// - Contains all imported MorseClaimableAccounts
    #[prost(bytes = "vec", tag = "2")]
    pub morse_account_state_hash: ::prost::alloc::vec::Vec<u8>,
    /// Number of claimable accounts (EOAs) imported from Morse state export
    /// - Account balances include consolidated application and supplier actor stakes
    #[prost(uint64, tag = "3")]
    pub num_accounts: u64,
}
impl ::prost::Name for EventImportMorseClaimableAccounts {
    const NAME: &'static str = "EventImportMorseClaimableAccounts";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.EventImportMorseClaimableAccounts".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.EventImportMorseClaimableAccounts".into()
    }
}
/// EventMorseAccountClaimed
/// - Emitted when a MorseAccount is claimed on-chain
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventMorseAccountClaimed {
    /// Shannon session end height in which the claim was committed
    #[prost(int64, tag = "1")]
    pub session_end_height: i64,
    /// Unstaked balance claimed from Morse
    #[prost(message, optional, tag = "2")]
    pub claimed_balance: ::core::option::Option<
        super::super::cosmos::base::v1beta1::Coin,
    >,
    /// bech32-encoded Shannon address to mint claimed balance
    #[prost(string, tag = "3")]
    pub shannon_dest_address: ::prost::alloc::string::String,
    /// Hex-encoded Morse account address whose balance was claimed
    #[prost(string, tag = "4")]
    pub morse_src_address: ::prost::alloc::string::String,
}
impl ::prost::Name for EventMorseAccountClaimed {
    const NAME: &'static str = "EventMorseAccountClaimed";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.EventMorseAccountClaimed".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.EventMorseAccountClaimed".into()
    }
}
/// EventMorseApplicationClaimed
/// - Emitted when a MorseAccount is claimed on-chain as a staked application
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventMorseApplicationClaimed {
    /// Shannon session end height in which the claim was committed
    #[prost(int64, tag = "1")]
    pub session_end_height: i64,
    /// Unstaked balance claimed from Morse
    #[prost(message, optional, tag = "2")]
    pub claimed_balance: ::core::option::Option<
        super::super::cosmos::base::v1beta1::Coin,
    >,
    /// Hex-encoded Morse account address whose balance was claimed
    #[prost(string, tag = "3")]
    pub morse_src_address: ::prost::alloc::string::String,
    /// Application stake claimed as a result of the claim
    /// - Equivalent to Morse application staked amount
    #[prost(message, optional, tag = "4")]
    pub claimed_application_stake: ::core::option::Option<
        super::super::cosmos::base::v1beta1::Coin,
    >,
    /// Application staked as a result of the claim
    /// - Mirrors Morse application stake
    #[prost(message, optional, tag = "5")]
    pub application: ::core::option::Option<super::application::Application>,
}
impl ::prost::Name for EventMorseApplicationClaimed {
    const NAME: &'static str = "EventMorseApplicationClaimed";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.EventMorseApplicationClaimed".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.EventMorseApplicationClaimed".into()
    }
}
/// EventMorseSupplierClaimed
/// - Emitted when a MorseAccount is claimed on-chain as a staked Supplier
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventMorseSupplierClaimed {
    /// Shannon session end height in which the claim was committed
    #[prost(int64, tag = "1")]
    pub session_end_height: i64,
    /// Unstaked balance claimed from Morse
    #[prost(message, optional, tag = "2")]
    pub claimed_balance: ::core::option::Option<
        super::super::cosmos::base::v1beta1::Coin,
    >,
    /// The hex-encoded address of the Morse non-custodial (i.e. operator) account.
    /// - Unstaked balance was migrated 1:1
    /// - Stake was migrated 1:1 from morse_node_address to shannon_operator_address
    /// - Morse non-custodial (i.e. operator) address.
    /// If morse_output_address was not set, this is the custodial address.
    /// - See 'pocket nodes --help' for more information. Note that this refers to the Morse CLI.
    /// E.g.: 00f9900606fa3d5c9179fc0c8513078a53a2073e
    #[prost(string, tag = "8")]
    pub morse_node_address: ::prost::alloc::string::String,
    /// ONLY applicable to Morse node/supplier accounts.
    /// Hex-encoded address of the Morse output account/wallet associated with the Morse node/supplier.
    /// - E.g.: 00f9900606fa3d5c9179fc0c8513078a53a2073e
    /// - Morse custodial (i.e. owner) address, which owned the staked tokens of the operator.
    ///    See 'pocket nodes --help' for more information. Note that this refers to the Morse CLI.
    #[prost(string, tag = "6")]
    pub morse_output_address: ::prost::alloc::string::String,
    /// The type of supplier claim signer, indicating which actor executed the claim
    /// and whether it was a custodial or non-custodial claim.
    /// - MORSE_SUPPLIER_CLAIM_SIGNER_TYPE_NON_CUSTODIAL_SIGNED_BY_ADDR
    /// - MORSE_SUPPLIER_CLAIM_SIGNER_TYPE_CUSTODIAL_SIGNED_BY_OPERATOR
    /// - MORSE_SUPPLIER_CLAIM_SIGNER_TYPE_CUSTODIAL_SIGNED_BY_OWNER
    #[prost(enumeration = "MorseSupplierClaimSignerType", tag = "7")]
    pub claim_signer_type: i32,
    /// Supplier stake claimed as a result of the claim
    /// - Equivalent to Morse supplier staked amount
    #[prost(message, optional, tag = "4")]
    pub claimed_supplier_stake: ::core::option::Option<
        super::super::cosmos::base::v1beta1::Coin,
    >,
    /// Supplier staked as a result of the claim
    /// - Mirrors Morse supplier stake
    #[prost(message, optional, tag = "5")]
    pub supplier: ::core::option::Option<super::shared::Supplier>,
}
impl ::prost::Name for EventMorseSupplierClaimed {
    const NAME: &'static str = "EventMorseSupplierClaimed";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.EventMorseSupplierClaimed".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.EventMorseSupplierClaimed".into()
    }
}
/// EventMorseAccountRecovered
/// - Emitted when a Morse account is recovered on-chain
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventMorseAccountRecovered {
    /// The session end height (on Shannon) in which the recovery was committed (i.e. claimed).
    #[prost(int64, tag = "1")]
    pub session_end_height: i64,
    /// The total balance which was recovered:
    /// - Includes both unstaked and staked balances (consolidated)
    /// - Auto-liquidates both unstaked and staked balances at once
    #[prost(message, optional, tag = "2")]
    pub recovered_balance: ::core::option::Option<
        super::super::cosmos::base::v1beta1::Coin,
    >,
    /// The bech32-encoded address of the Shannon account to which the recovered balance was minted.
    #[prost(string, tag = "3")]
    pub shannon_dest_address: ::prost::alloc::string::String,
    /// The hex-encoded address of the Morse account whose balance and stakes have been recovered.
    /// This address MUST be in the recovery allow list and could be of types such as:
    /// - Unreachable/Locked EOA, Supplier or Application address
    /// - Module account
    /// - Invalid address (too short, too long, or non-hexadecimal format)
    #[prost(string, tag = "4")]
    pub morse_src_address: ::prost::alloc::string::String,
}
impl ::prost::Name for EventMorseAccountRecovered {
    const NAME: &'static str = "EventMorseAccountRecovered";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.EventMorseAccountRecovered".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.EventMorseAccountRecovered".into()
    }
}
/// Params defines the parameters for the module.
///
/// Next free index: 4
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Params {
    /// waive_morse_claim_gas_fees is a feature flag used to enable/disable the waiving of gas fees for txs that:
    /// - Contain exactly one secp256k1 signer
    /// - Contain at least one Morse account/actor claim messages
    /// - Do not contain any other messages other than Morse account/actor claim messages
    #[prost(bool, tag = "1")]
    pub waive_morse_claim_gas_fees: bool,
    /// allow_morse_account_import_overwrite is a feature flag which is used to enable/disable
    /// the re-importing of Morse claimable accounts by the authority.
    /// Such a re-import will:
    /// - Ignore (i.e. leave) ALL claimed destination Shannon accounts/actors
    /// - Delete ALL existing onchain MorseClaimableAccounts
    /// - Import the new set of MorseClaimableAccounts from the provided MsgImportMorseClaimableAccounts
    /// This is useful for testing purposes, but should be disabled in production.
    #[prost(bool, tag = "2")]
    pub allow_morse_account_import_overwrite: bool,
    /// morse_account_claiming_enabled is a feature flag which is used to enable/disable the processing of Morse account/actor claim messages
    /// (i.e. `MsgClaimMorseAccount`, `MorseClaimApplication`, and `MorseClaimSupplier`).
    #[prost(bool, tag = "3")]
    pub morse_account_claiming_enabled: bool,
}
impl ::prost::Name for Params {
    const NAME: &'static str = "Params";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.Params".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.Params".into()
    }
}
/// GenesisState defines the migration module's genesis state.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenesisState {
    /// params defines all the parameters of the module.
    #[prost(message, optional, tag = "1")]
    pub params: ::core::option::Option<Params>,
    #[prost(message, repeated, tag = "2")]
    pub morse_claimable_account_list: ::prost::alloc::vec::Vec<MorseClaimableAccount>,
}
impl ::prost::Name for GenesisState {
    const NAME: &'static str = "GenesisState";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.GenesisState".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.GenesisState".into()
    }
}
/// MorseStateExport is the data structure that is serialized and output when running:
///   $ pocket utils export-genesis-for-reset ...
///
/// Ref: <https://editor.swagger.io/?url=https://raw.githubusercontent.com/pokt-network/pocket-core/staging/doc/specs/rpc-spec.yaml#operations-query-post_query_state>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MorseStateExport {
    /// app_hash is the Morse tendermint state hash.
    #[prost(string, tag = "1")]
    pub app_hash: ::prost::alloc::string::String,
    /// app_state is the entire Morse tendermint application state.
    #[prost(message, optional, tag = "2")]
    pub app_state: ::core::option::Option<MorseTendermintAppState>,
}
impl ::prost::Name for MorseStateExport {
    const NAME: &'static str = "MorseStateExport";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MorseStateExport".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MorseStateExport".into()
    }
}
/// MorseTendermintAppState is the tendermint application state for the Morse tendermint
/// application; not to be confused with the pokt protocol actor.
/// It is constructed in Morse via `PocketCoreApp#ExportAppState()`.
///
/// See: <https://github.com/pokt-network/pocket-core/blob/5fa61920aa9d45ca6bf9e01e863134e242c95fa7/app/pocket.go#L142>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MorseTendermintAppState {
    #[prost(message, optional, tag = "1")]
    pub application: ::core::option::Option<MorseApplications>,
    #[prost(message, optional, tag = "2")]
    pub auth: ::core::option::Option<MorseAuth>,
    #[prost(message, optional, tag = "3")]
    pub pos: ::core::option::Option<MorsePos>,
}
impl ::prost::Name for MorseTendermintAppState {
    const NAME: &'static str = "MorseTendermintAppState";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MorseTendermintAppState".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MorseTendermintAppState".into()
    }
}
/// A wrapper around the list of MorseApplications, necessary in order to conform to the Morse genesis structure.
/// It encapsulates the minimum information required to import Morse applications.
///
/// See: <https://github.com/pokt-network/pocket-core/blob/staging/x/apps/types/genesis.go#L4>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MorseApplications {
    #[prost(message, repeated, tag = "1")]
    pub applications: ::prost::alloc::vec::Vec<MorseApplication>,
}
impl ::prost::Name for MorseApplications {
    const NAME: &'static str = "MorseApplications";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MorseApplications".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MorseApplications".into()
    }
}
/// A wrapper around a list of MorseAuthAccount.
/// It encapsulates the minimum information required to import Morse accounts.
///
/// See: <https://github.com/pokt-network/pocket-core/blob/staging/x/auth/types/genesis.go#L9>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MorseAuth {
    #[prost(message, repeated, tag = "1")]
    pub accounts: ::prost::alloc::vec::Vec<MorseAuthAccount>,
}
impl ::prost::Name for MorseAuth {
    const NAME: &'static str = "MorseAuth";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MorseAuth".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MorseAuth".into()
    }
}
/// MorseAuthAccount:
/// * Wraps MorseAuthAccount information to conform to Morse genesis structure
/// * Can represent EITHER an externally owned account OR a module account
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MorseAuthAccount {
    #[prost(string, tag = "1")]
    pub r#type: ::prost::alloc::string::String,
    /// value is a EITHER a JSON-encoded MorseAccount or a MorseModuleAccount.
    #[prost(bytes = "vec", tag = "3")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for MorseAuthAccount {
    const NAME: &'static str = "MorseAuthAccount";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MorseAuthAccount".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MorseAuthAccount".into()
    }
}
/// A wrapper around the list of Morse suppliers (aka "validators", "nodes", of "servicers").
/// It is necessary to conform to the Morse genesis structure.
///
/// See: <https://github.com/pokt-network/pocket-core/blob/staging/x/nodes/types/genesis.go#L8>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MorsePos {
    #[prost(message, repeated, tag = "1")]
    pub validators: ::prost::alloc::vec::Vec<MorseValidator>,
}
impl ::prost::Name for MorsePos {
    const NAME: &'static str = "MorsePos";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MorsePos".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MorsePos".into()
    }
}
/// MorseApplication is a subset of the Morse ProtoApplication type.
/// It encapsulates the minimum information required to import Morse applications.
///
/// See: <https://github.com/pokt-network/pocket-core/blob/staging/proto/x/apps/apps.proto#L16>
///
/// Next free index: 9
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MorseApplication {
    /// Address is a binary representation of the address corresponding
    /// to a Morse application's ed25519 public key.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// PublicKey is the binary representation of a Morse application's ed25519 public key.
    #[prost(bytes = "vec", tag = "2")]
    pub public_key: ::prost::alloc::vec::Vec<u8>,
    /// TODO_MAINNET_MIGRATION(@Olshansk):  Should status and/or jailed be considered during the migration, and if so, how?
    #[prost(bool, tag = "3")]
    pub jailed: bool,
    #[prost(int32, tag = "4")]
    pub status: i32,
    /// The string representation of the BigInt amount of upokt.
    #[prost(string, tag = "6")]
    pub staked_tokens: ::prost::alloc::string::String,
    /// The ISO 8601 UTC timestamp after which the Morse node/supplier unbonding period will have elapsed.
    /// It reflects the "unbonding completion time" of the Morse node/supplier, but is called "unstaking time" to comply with necessary Morse data structures.
    #[prost(message, optional, tag = "8")]
    pub unstaking_time: ::core::option::Option<::prost_types::Timestamp>,
}
impl ::prost::Name for MorseApplication {
    const NAME: &'static str = "MorseApplication";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MorseApplication".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MorseApplication".into()
    }
}
/// MorseValidator is a subset of the Morse ProtoValidator type.
/// It encapsulates the minimum information required to import Morse suppliers (aka "servicers" or "validators").
///
/// See: <https://github.com/pokt-network/pocket-core/blob/staging/proto/x/pos/types.proto#L16>
///
/// Next free index: 10
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MorseValidator {
    /// Morse non-custodial (i.e. operator) address. If output_address is not set, this is the custodial address.
    /// Binary representation of the Morse address corresponding to a Morse node's ed25519 public key.
    /// See 'pocket nodes --help' for more information. Note that this refers to the Morse CLI.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// Binary representation of a Morse node's ed25519 public key.
    #[prost(bytes = "vec", tag = "2")]
    pub public_key: ::prost::alloc::vec::Vec<u8>,
    /// TODO_MAINNET_MIGRATION(@Olshansk):  Should status and/or jailed be considered during the migration, and if so, how?
    #[prost(bool, tag = "3")]
    pub jailed: bool,
    #[prost(int32, tag = "4")]
    pub status: i32,
    /// The string representation of the BigInt amount of upokt.
    #[prost(string, tag = "7")]
    pub staked_tokens: ::prost::alloc::string::String,
    /// The ISO 8601 UTC timestamp after which the Morse node/supplier unbonding period will have elapsed.
    /// It reflects the "unbonding completion time" of the Morse node/supplier, but is called "unstaking time" to comply with necessary Morse data structures.
    #[prost(message, optional, tag = "8")]
    pub unstaking_time: ::core::option::Option<::prost_types::Timestamp>,
    /// Morse custodial (i.e. owner) address, which owns the staked tokens of the operator.
    /// Binary representation of the Morse address corresponding to a Morse account's ed25519 public key.
    /// See 'pocket nodes --help' for more information. Note that this refers to the Morse CLI.
    #[prost(bytes = "vec", tag = "9")]
    pub output_address: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for MorseValidator {
    const NAME: &'static str = "MorseValidator";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MorseValidator".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MorseValidator".into()
    }
}
/// MorseAccount is an analog of the Morse ProtoBaseAccount type.
/// It encapsulates the minimum information required to import accounts.
///
/// See: <https://github.com/pokt-network/pocket-core/blob/staging/proto/x/auth/auth.proto#L14.>
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MorseAccount {
    /// A hex-encoded representation of the address corresponding to a Morse application's ed25519 public key.
    #[prost(bytes = "vec", tag = "1")]
    pub address: ::prost::alloc::vec::Vec<u8>,
    /// The ed25519 public key of the account.
    #[prost(message, optional, tag = "2")]
    pub pub_key: ::core::option::Option<MorsePublicKey>,
    /// The account balance; this does not include any actor stakes.
    #[prost(message, repeated, tag = "3")]
    pub coins: ::prost::alloc::vec::Vec<super::super::cosmos::base::v1beta1::Coin>,
}
impl ::prost::Name for MorseAccount {
    const NAME: &'static str = "MorseAccount";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MorseAccount".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MorseAccount".into()
    }
}
/// MorsePublicKey is required to conform to the encoding of the Morse state export.
/// NB: All Morse account public keys will be ed25519 keys by definition.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MorsePublicKey {
    #[prost(bytes = "vec", tag = "2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for MorsePublicKey {
    const NAME: &'static str = "MorsePublicKey";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MorsePublicKey".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MorsePublicKey".into()
    }
}
/// MorseModuleAccount is the module account type for Morse, it wraps a MorseAccount
/// and has a unique name, which is used instead of the address.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MorseModuleAccount {
    /// DEV_NOTE: the JSON tag is intentionally cased contrary to convention to match the real-world Morse state export.
    #[prost(message, optional, tag = "1")]
    pub base_account: ::core::option::Option<MorseAccount>,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
}
impl ::prost::Name for MorseModuleAccount {
    const NAME: &'static str = "MorseModuleAccount";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MorseModuleAccount".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MorseModuleAccount".into()
    }
}
/// QueryParamsRequest is request type for the Query/Params RPC method.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryParamsRequest {}
impl ::prost::Name for QueryParamsRequest {
    const NAME: &'static str = "QueryParamsRequest";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.QueryParamsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.QueryParamsRequest".into()
    }
}
/// QueryParamsResponse is response type for the Query/Params RPC method.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryParamsResponse {
    /// params holds all the parameters of this module.
    #[prost(message, optional, tag = "1")]
    pub params: ::core::option::Option<Params>,
}
impl ::prost::Name for QueryParamsResponse {
    const NAME: &'static str = "QueryParamsResponse";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.QueryParamsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.QueryParamsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryMorseClaimableAccountRequest {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryMorseClaimableAccountRequest {
    const NAME: &'static str = "QueryMorseClaimableAccountRequest";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.QueryMorseClaimableAccountRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.QueryMorseClaimableAccountRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryMorseClaimableAccountResponse {
    #[prost(message, optional, tag = "1")]
    pub morse_claimable_account: ::core::option::Option<MorseClaimableAccount>,
}
impl ::prost::Name for QueryMorseClaimableAccountResponse {
    const NAME: &'static str = "QueryMorseClaimableAccountResponse";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.QueryMorseClaimableAccountResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.QueryMorseClaimableAccountResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAllMorseClaimableAccountRequest {
    #[prost(message, optional, tag = "1")]
    pub pagination: ::core::option::Option<
        super::super::cosmos::base::query::v1beta1::PageRequest,
    >,
}
impl ::prost::Name for QueryAllMorseClaimableAccountRequest {
    const NAME: &'static str = "QueryAllMorseClaimableAccountRequest";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.QueryAllMorseClaimableAccountRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.QueryAllMorseClaimableAccountRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAllMorseClaimableAccountResponse {
    #[prost(message, repeated, tag = "1")]
    pub morse_claimable_account: ::prost::alloc::vec::Vec<MorseClaimableAccount>,
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        super::super::cosmos::base::query::v1beta1::PageResponse,
    >,
}
impl ::prost::Name for QueryAllMorseClaimableAccountResponse {
    const NAME: &'static str = "QueryAllMorseClaimableAccountResponse";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.QueryAllMorseClaimableAccountResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.QueryAllMorseClaimableAccountResponse".into()
    }
}
/// Generated client implementations.
pub mod query_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Query defines the gRPC querier service.
    #[derive(Debug, Clone)]
    pub struct QueryClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl QueryClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> QueryClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> QueryClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            QueryClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Parameters queries the parameters of the module.
        pub async fn params(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryParamsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryParamsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pocket.migration.Query/Params",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pocket.migration.Query", "Params"));
            self.inner.unary(req, path, codec).await
        }
        /// Queries a list of MorseClaimableAccount items.
        pub async fn morse_claimable_account(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryMorseClaimableAccountRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryMorseClaimableAccountResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pocket.migration.Query/MorseClaimableAccount",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("pocket.migration.Query", "MorseClaimableAccount"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn morse_claimable_account_all(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryAllMorseClaimableAccountRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryAllMorseClaimableAccountResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pocket.migration.Query/MorseClaimableAccountAll",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("pocket.migration.Query", "MorseClaimableAccountAll"),
                );
            self.inner.unary(req, path, codec).await
        }
    }
}
/// MsgUpdateParams is the Msg/UpdateParams request type.
///
/// - Used for updating the migration module parameters via governance
/// - All parameters must be supplied
///
/// Next free index: 3
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUpdateParams {
    /// authority is the address that controls the module (defaults to x/gov unless overwritten).
    #[prost(string, tag = "1")]
    pub authority: ::prost::alloc::string::String,
    /// Module parameters to update
    /// NOTE: All parameters must be supplied
    #[prost(message, optional, tag = "2")]
    pub params: ::core::option::Option<Params>,
}
impl ::prost::Name for MsgUpdateParams {
    const NAME: &'static str = "MsgUpdateParams";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MsgUpdateParams".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MsgUpdateParams".into()
    }
}
/// MsgUpdateParamsResponse defines the response structure for executing a MsgUpdateParams message.
///
/// - Empty response on success
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgUpdateParamsResponse {}
impl ::prost::Name for MsgUpdateParamsResponse {
    const NAME: &'static str = "MsgUpdateParamsResponse";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MsgUpdateParamsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MsgUpdateParamsResponse".into()
    }
}
/// MsgImportMorseClaimableAccounts is used to:
///
/// - Create the on-chain MorseClaimableAccounts ONLY AND EXACTLY ONCE (per network / re-genesis)
/// - Import Morse account state derived from Morse state export
///
/// Next free index: 4
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgImportMorseClaimableAccounts {
    /// authority is the address that controls the module (defaults to x/gov unless overwritten).
    #[prost(string, tag = "1")]
    pub authority: ::prost::alloc::string::String,
    /// Account state derived from Morse state export and `pocketd tx migration collect-morse-accounts`
    #[prost(message, optional, tag = "2")]
    pub morse_account_state: ::core::option::Option<MorseAccountState>,
    /// Validates the morse_account_state sha256 hash:
    /// - Transaction fails if hash doesn't match on-chain computation
    /// - Off-chain social consensus should be reached before verification
    ///
    /// Verification (high-level):
    ///    $ pocketd tx migration collect-morse-accounts $<(pocket util export-genesis-for-reset)
    ///
    /// Additional docs:
    ///    - pocket util export-genesis-for-migration --help
    ///    - pocketd tx migration collect-morse-accounts --help
    #[prost(bytes = "vec", tag = "3")]
    pub morse_account_state_hash: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for MsgImportMorseClaimableAccounts {
    const NAME: &'static str = "MsgImportMorseClaimableAccounts";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MsgImportMorseClaimableAccounts".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MsgImportMorseClaimableAccounts".into()
    }
}
/// MsgImportMorseClaimableAccountsResponse is returned from MsgImportMorseClaimableAccounts.
///
/// - Indicates the canonical hash of the imported MorseAccountState
/// - Reports the number of claimable accounts imported
///
/// Next free index: 3
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgImportMorseClaimableAccountsResponse {
    /// On-chain computed sha256 hash of the morse_account_state provided in the corresponding MsgCreateMorseAccountState.
    #[prost(bytes = "vec", tag = "1")]
    pub state_hash: ::prost::alloc::vec::Vec<u8>,
    /// Number of claimable accounts (EOAs) collected from Morse state export.
    #[prost(uint64, tag = "2")]
    pub num_accounts: u64,
}
impl ::prost::Name for MsgImportMorseClaimableAccountsResponse {
    const NAME: &'static str = "MsgImportMorseClaimableAccountsResponse";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MsgImportMorseClaimableAccountsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MsgImportMorseClaimableAccountsResponse".into()
    }
}
/// MsgClaimMorseAccount is used to:
///
/// - Execute a claim (one-time minting of tokens on Shannon)
/// - Claim the balance of a given Morse account per on-chain MorseClaimableAccounts
/// - Mint claimed balance to the given Shannon account
///
/// NOTE:
/// - A transaction can contain ONE OR MORE Morse account/actor claim messages AND has EXACTLY ONE signer.
/// - The Shannon account specified must be the message signer
/// - Authz grants MAY be used to delegate claiming authority to other Shannon accounts
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgClaimMorseAccount {
    /// The bech32-encoded address of the Shannon account which is signing for this message.
    /// This account is liable for any fees incurred by violating the constraints of Morse
    /// account/actor claim message fee waiving.
    #[prost(string, tag = "4")]
    pub shannon_signing_address: ::prost::alloc::string::String,
    /// The bech32-encoded address of the Shannon account to which the claimed balance will be minted.
    #[prost(string, tag = "1")]
    pub shannon_dest_address: ::prost::alloc::string::String,
    /// The ed25519 public key of the morse account with morse_src_address.
    #[prost(bytes = "vec", tag = "5")]
    pub morse_public_key: ::prost::alloc::vec::Vec<u8>,
    /// The hex-encoded signature, by the Morse account, of this message (where this field is nil).
    /// I.e.: morse_signature = private_key.sign(marshal(MsgClaimMorseAccount{morse_signature: nil, ...}))
    #[prost(bytes = "vec", tag = "3")]
    pub morse_signature: ::prost::alloc::vec::Vec<u8>,
}
impl ::prost::Name for MsgClaimMorseAccount {
    const NAME: &'static str = "MsgClaimMorseAccount";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MsgClaimMorseAccount".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MsgClaimMorseAccount".into()
    }
}
/// MsgClaimMorseAccountResponse is returned from MsgClaimMorseAccount.
///
/// - Indicates the morse_src_address of the claimed account
/// - Reports the claimed balance and commit height
///
/// Next free index: 4
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgClaimMorseAccountResponse {
    /// The hex-encoded address of the Morse account whose balance will be claimed.
    /// E.g.: 00f9900606fa3d5c9179fc0c8513078a53a2073e
    #[prost(string, tag = "1")]
    pub morse_src_address: ::prost::alloc::string::String,
    /// The balance which was claimed.
    #[prost(message, optional, tag = "2")]
    pub claimed_balance: ::core::option::Option<
        super::super::cosmos::base::v1beta1::Coin,
    >,
    /// The session end height (on Shannon) in which the claim was committed (i.e. claimed).
    #[prost(int64, tag = "3")]
    pub session_end_height: i64,
}
impl ::prost::Name for MsgClaimMorseAccountResponse {
    const NAME: &'static str = "MsgClaimMorseAccountResponse";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MsgClaimMorseAccountResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MsgClaimMorseAccountResponse".into()
    }
}
/// MsgClaimMorseApplication is used to:
///
/// - Execute a claim (one-time minting of tokens on Shannon) of total tokens owned by a Morse account
/// - Mint claimed tokens to the given Shannon account
/// - Stake that Shannon account as an application for the given service_config and same stake amount
///
/// Next free index: 7
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgClaimMorseApplication {
    /// The bech32-encoded address of the Shannon account which is signing for this message.
    /// This account is liable for any fees incurred by violating the constraints of Morse
    /// account/actor claim message fee waiving; the tx contains ONE OR MORE Morse account/actor
    /// claim messages AND has EXACTLY ONE signer.
    #[prost(string, tag = "5")]
    pub shannon_signing_address: ::prost::alloc::string::String,
    /// The bech32-encoded address of the Shannon account to which the claimed tokens
    /// will be minted and from which the application will be staked.
    #[prost(string, tag = "1")]
    pub shannon_dest_address: ::prost::alloc::string::String,
    /// The ed25519 public key of the morse account with morse_src_address.
    #[prost(bytes = "vec", tag = "6")]
    pub morse_public_key: ::prost::alloc::vec::Vec<u8>,
    /// The hex-encoded signature, by the Morse account, of this message (where this field is nil).
    /// I.e.: morse_signature = private_key.sign(marshal(MsgClaimMorseAccount{morse_signature: nil, ...}))
    #[prost(bytes = "vec", tag = "3")]
    pub morse_signature: ::prost::alloc::vec::Vec<u8>,
    /// The services this application is staked to request service for.
    /// NOTE: This is not a repeated field, as in MsgStakeApplication,
    /// because an application can only be staked for one service.
    #[prost(message, optional, tag = "4")]
    pub service_config: ::core::option::Option<super::shared::ApplicationServiceConfig>,
}
impl ::prost::Name for MsgClaimMorseApplication {
    const NAME: &'static str = "MsgClaimMorseApplication";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MsgClaimMorseApplication".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MsgClaimMorseApplication".into()
    }
}
/// MsgClaimMorseApplicationResponse is returned from MsgClaimMorseApplication.
///
/// - Indicates the morse_src_address of the claimed account
/// - Reports the unstaked balance claimed, application stake, and commit height
/// - Returns the staked application
///
/// Next free index: 6
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgClaimMorseApplicationResponse {
    /// The hex-encoded address of the Morse account whose balance will be claimed.
    #[prost(string, tag = "1")]
    pub morse_src_address: ::prost::alloc::string::String,
    /// The unstaked balance which was claimed.
    #[prost(message, optional, tag = "2")]
    pub claimed_balance: ::core::option::Option<
        super::super::cosmos::base::v1beta1::Coin,
    >,
    /// The stake of the application which was staked as a result of the claim.
    /// If the application was already staked, this amount does not include the initial stake (i.e. only the portion which was "claimed").
    #[prost(message, optional, tag = "3")]
    pub claimed_application_stake: ::core::option::Option<
        super::super::cosmos::base::v1beta1::Coin,
    >,
    /// The session end height (on Shannon) in which the claim was committed (i.e. claimed).
    #[prost(int64, tag = "4")]
    pub session_end_height: i64,
    /// The application which was staked as a result of the claim.
    #[prost(message, optional, tag = "5")]
    pub application: ::core::option::Option<super::application::Application>,
}
impl ::prost::Name for MsgClaimMorseApplicationResponse {
    const NAME: &'static str = "MsgClaimMorseApplicationResponse";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MsgClaimMorseApplicationResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MsgClaimMorseApplicationResponse".into()
    }
}
/// MsgClaimMorseSupplier is used to:
///
/// - Execute a one-time minting of tokens on Shannon based on tokens owned by the given Morse account
/// - Use the on-chain MorseClaimableAccounts for verification
/// - Credit the minted tokens to the balance of the given Shannon account
/// - Automatically stake that Shannon account as a supplier
///
/// NOTE: The supplier module's staking fee parameter (at the time of claiming) is deducted from the claimed balance
///
/// Next free index: 9
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgClaimMorseSupplier {
    /// The bech32-encoded address of the Shannon account which is signing for this message.
    /// This account is liable for any fees incurred by violating the constraints of Morse
    /// account/actor claim message fee waiving; the tx contains ONE OR MORE Morse account/actor
    /// claim messages AND has EXACTLY ONE signer.
    #[prost(string, tag = "6")]
    pub shannon_signing_address: ::prost::alloc::string::String,
    /// The bech32-encoded address of the Shannon account to which the claimed tokens
    /// will be minted and which become the supplier owner.
    /// See: <https://dev.poktroll.com/operate/configs/supplier_staking_config#staking-types.>
    #[prost(string, tag = "1")]
    pub shannon_owner_address: ::prost::alloc::string::String,
    /// The bech32-encoded address of the Shannon account to which will become the supplier operator.
    /// If empty, the shannon_owner_address will be used.
    /// See: <https://dev.poktroll.com/operate/configs/supplier_staking_config#staking-types.>
    #[prost(string, tag = "2")]
    pub shannon_operator_address: ::prost::alloc::string::String,
    /// The hex-encoded address of the Morse non-custodial (i.e. operator) account.
    /// - Unstaked balance will be migrated 1:1
    /// - Stake will be migrated 1:1 from morse_node_address to shannon_operator_address
    /// - Morse non-custodial (i.e. operator) address.
    /// If morse_output_address is not set, this is the custodial address.
    /// - See 'pocket nodes --help' for more information. Note that this refers to the Morse CLI.
    /// E.g.: 00f9900606fa3d5c9179fc0c8513078a53a2073e
    #[prost(string, tag = "3")]
    pub morse_node_address: ::prost::alloc::string::String,
    /// The ed25519 public key of EITHER the Morse node/supplier operator OR owner account.
    /// - MUST correspond to the private key which was used to produce the morse_signature.
    /// - MUST correspond to ONE OF THE FOLLOWING:
    ///    - morse_node_address
    ///    - morse_output_address
    #[prost(bytes = "vec", tag = "7")]
    pub morse_public_key: ::prost::alloc::vec::Vec<u8>,
    /// The hex-encoded signature, of this message (where this field is nil).
    /// I.e.: morse_signature = private_key.sign(marshal(MsgClaimMorseSupplier{morse_signature: nil, ...}))
    /// - MUST match morse_public_key.
    /// - MUST be signed by ONE OF THE FOLLOWING:
    ///    - Morse node account (i.e. operator); if signer_is_output_address is false
    ///    - Morse output account (i.e. owner); if signer_is_output_address is true
    #[prost(bytes = "vec", tag = "4")]
    pub morse_signature: ::prost::alloc::vec::Vec<u8>,
    /// Set to true if the private key corresponding to the morse_output_address is producing the morse_signature.
    /// For non-custodial claiming:
    /// - This MUST be true.
    /// - The morse_public_key MUST correspond to morse_output_address.
    /// - The morse_signature MUST correspond to morse_output_address.
    #[prost(bool, tag = "8")]
    pub signer_is_output_address: bool,
    /// The services this supplier is staked to provide service for.
    #[prost(message, repeated, tag = "5")]
    pub services: ::prost::alloc::vec::Vec<super::shared::SupplierServiceConfig>,
}
impl ::prost::Name for MsgClaimMorseSupplier {
    const NAME: &'static str = "MsgClaimMorseSupplier";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MsgClaimMorseSupplier".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MsgClaimMorseSupplier".into()
    }
}
/// MsgClaimMorseSupplierResponse is returned from MsgClaimMorseSupplier.
///
/// - Indicates the morse_operator_address of the claimed account
/// - Reports the unstaked balance claimed, session end height, and staked supplier
/// - Includes claim signer type and signer address
///
/// Next free index: 10
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgClaimMorseSupplierResponse {
    /// The hex-encoded address of the Morse non-custodial (i.e. operator) account.
    /// - Unstaked balance will be migrated 1:1
    /// - Stake will be migrated 1:1 from morse_node_address to shannon_operator_address
    /// - Morse non-custodial (i.e. operator) address.
    /// If morse_output_address is not set, this is the custodial address.
    /// - See 'pocket nodes --help' for more information. Note that this refers to the Morse CLI.
    /// E.g.: 00f9900606fa3d5c9179fc0c8513078a53a2073e
    #[prost(string, tag = "9")]
    pub morse_node_address: ::prost::alloc::string::String,
    /// Hex-encoded address of the Morse output account/wallet associated with the Morse node/supplier.
    /// - E.g.: 00f9900606fa3d5c9179fc0c8513078a53a2073e
    /// - Morse custodial (i.e. owner) address, which owns the staked tokens of the operator.
    ///    See 'pocket nodes --help' for more information. Note that this refers to the Morse CLI.
    #[prost(string, tag = "8")]
    pub morse_output_address: ::prost::alloc::string::String,
    /// The type of supplier claim signer, indicating which actor executed the claim
    /// and whether it was a custodial or non-custodial claim.
    /// - MORSE_SUPPLIER_CLAIM_SIGNER_TYPE_NON_CUSTODIAL_SIGNED_BY_ADDR
    /// - MORSE_SUPPLIER_CLAIM_SIGNER_TYPE_CUSTODIAL_SIGNED_BY_OPERATOR
    /// - MORSE_SUPPLIER_CLAIM_SIGNER_TYPE_CUSTODIAL_SIGNED_BY_OWNER
    #[prost(enumeration = "MorseSupplierClaimSignerType", tag = "7")]
    pub claim_signer_type: i32,
    /// The unstaked balance which was claimed.
    #[prost(message, optional, tag = "2")]
    pub claimed_balance: ::core::option::Option<
        super::super::cosmos::base::v1beta1::Coin,
    >,
    #[prost(message, optional, tag = "3")]
    pub claimed_supplier_stake: ::core::option::Option<
        super::super::cosmos::base::v1beta1::Coin,
    >,
    /// The session end height (on Shannon) in which the claim was committed (i.e. claimed).
    #[prost(int64, tag = "4")]
    pub session_end_height: i64,
    /// The supplier which was staked as a result of the claim.
    #[prost(message, optional, tag = "5")]
    pub supplier: ::core::option::Option<super::shared::Supplier>,
}
impl ::prost::Name for MsgClaimMorseSupplierResponse {
    const NAME: &'static str = "MsgClaimMorseSupplierResponse";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MsgClaimMorseSupplierResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MsgClaimMorseSupplierResponse".into()
    }
}
/// MsgRecoverMorseAccount is used to:
///
/// - Execute a one-time minting of tokens on Shannon based on tokens owned by the given Morse account
/// - Credit the minted tokens to the balance of the given Shannon account
/// - Migrate unclaimable staked and liquid Morse tokens as liquid Shannon tokens
///
/// - MAY ONLY be executed by the authority
/// - ONLY intended for use on accounts with invalid addresses and/or known lost private keys
///
/// Next free index: 4
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgRecoverMorseAccount {
    /// The bech32-encoded address of the migration module authority account ("gov" module address by default).
    /// ONLY the authority, or its delegates, MAY recover Morse recoverable accounts.
    #[prost(string, tag = "1")]
    pub authority: ::prost::alloc::string::String,
    /// The bech32-encoded address of the Shannon account to which the Morse account's stake(s) and/or
    /// balance(s) will be minted (recovered) as liquid Shannon tokens.
    #[prost(string, tag = "2")]
    pub shannon_dest_address: ::prost::alloc::string::String,
    /// EITHER:
    /// - The hex-encoded address of the recoverable Morse account whose stake(s) and/or balance(s) will be recovered.
    ///    This address MAY be invalid but NEVER empty.
    ///    E.g.: 00f9900606fa3d5c9179fc0c8513078a53a2073e
    /// - The name of a Morse module account whose balance will be recovered.
    ///    E.g. "dao" or "fee-collector"
    #[prost(string, tag = "3")]
    pub morse_src_address: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgRecoverMorseAccount {
    const NAME: &'static str = "MsgRecoverMorseAccount";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MsgRecoverMorseAccount".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MsgRecoverMorseAccount".into()
    }
}
/// MsgRecoverMorseAccountResponse is returned from MsgRecoverMorseAccount.
///
/// - Indicates the morse_src_address of the recovered account
/// - Reports the sum of any actor stakes and unstaked balance recovered
/// - Reports the session end height in which the recovery was committed
/// - Returns the destination Shannon address
///
/// Next free index: 5
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgRecoverMorseAccountResponse {
    /// EITHER:
    /// - The hex-encoded address of the Morse account whose stake(s) and/or balances were recovered.
    ///    This address MAY be invalid but NEVER empty.
    ///    E.g.: 00f9900606fa3d5c9179fc0c8513078a53a2073e
    /// - The name of a Morse module account whose balance was recovered.
    ///    E.g. "dao" or "fee-collector"
    #[prost(string, tag = "1")]
    pub morse_src_address: ::prost::alloc::string::String,
    /// The sum of any unstaked and staked balances which were recovered.
    #[prost(message, optional, tag = "2")]
    pub recovered_balance: ::core::option::Option<
        super::super::cosmos::base::v1beta1::Coin,
    >,
    /// The session end height (on Shannon) in which the recovery was committed (i.e. recovered).
    #[prost(int64, tag = "3")]
    pub session_end_height: i64,
    /// The bech32-encoded address of the Shannon account to which the Morse account's stake(s) and/or
    /// balance(s) were recovered.
    #[prost(string, tag = "4")]
    pub shannon_dest_address: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgRecoverMorseAccountResponse {
    const NAME: &'static str = "MsgRecoverMorseAccountResponse";
    const PACKAGE: &'static str = "pocket.migration";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.migration.MsgRecoverMorseAccountResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.migration.MsgRecoverMorseAccountResponse".into()
    }
}
/// Generated client implementations.
pub mod msg_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Msg defines the Msg service.
    ///
    /// - Provides RPCs for migration-related operations
    /// - Includes parameter updates, Morse account claims, supplier claims, and recovery
    #[derive(Debug, Clone)]
    pub struct MsgClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl MsgClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> MsgClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MsgClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            MsgClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// UpdateParams defines a (governance) operation for updating the module
        /// parameters. The authority defaults to the x/gov module account.
        pub async fn update_params(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgUpdateParams>,
        ) -> std::result::Result<
            tonic::Response<super::MsgUpdateParamsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pocket.migration.Msg/UpdateParams",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pocket.migration.Msg", "UpdateParams"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn import_morse_claimable_accounts(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgImportMorseClaimableAccounts>,
        ) -> std::result::Result<
            tonic::Response<super::MsgImportMorseClaimableAccountsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pocket.migration.Msg/ImportMorseClaimableAccounts",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new(
                        "pocket.migration.Msg",
                        "ImportMorseClaimableAccounts",
                    ),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn claim_morse_account(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgClaimMorseAccount>,
        ) -> std::result::Result<
            tonic::Response<super::MsgClaimMorseAccountResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pocket.migration.Msg/ClaimMorseAccount",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pocket.migration.Msg", "ClaimMorseAccount"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn claim_morse_application(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgClaimMorseApplication>,
        ) -> std::result::Result<
            tonic::Response<super::MsgClaimMorseApplicationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pocket.migration.Msg/ClaimMorseApplication",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("pocket.migration.Msg", "ClaimMorseApplication"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn claim_morse_supplier(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgClaimMorseSupplier>,
        ) -> std::result::Result<
            tonic::Response<super::MsgClaimMorseSupplierResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pocket.migration.Msg/ClaimMorseSupplier",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pocket.migration.Msg", "ClaimMorseSupplier"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn recover_morse_account(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgRecoverMorseAccount>,
        ) -> std::result::Result<
            tonic::Response<super::MsgRecoverMorseAccountResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pocket.migration.Msg/RecoverMorseAccount",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pocket.migration.Msg", "RecoverMorseAccount"));
            self.inner.unary(req, path, codec).await
        }
    }
}
