// This file is @generated by prost-build.
/// Application represents the onchain definition and state of an application
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Application {
    /// Bech32 address of the application
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    /// Total amount of staked uPOKT
    #[prost(message, optional, tag = "2")]
    pub stake: ::core::option::Option<super::super::cosmos::base::v1beta1::Coin>,
    /// CRITICAL: Must contain EXACTLY ONE service config
    /// - Enforces a single service configuration per application to prevent over-servicing.
    /// - Field is repeated for legacy reasons and potential future compatibility.
    /// - References for rationale:
    ///    - <https://github.com/pokt-network/poktroll/pull/750#discussion_r1735025033>
    ///    - <https://www.notion.so/buildwithgrove/Off-chain-Application-Stake-Tracking-6a8bebb107db4f7f9dc62cbe7ba555f7>
    #[prost(message, repeated, tag = "3")]
    pub service_configs: ::prost::alloc::vec::Vec<
        super::shared::ApplicationServiceConfig,
    >,
    /// TODO_MAINNET_MIGRATION(@bryanchriswhite): Rename `delegatee_gateway_addresses` to `gateway_addresses_delegated_to` for better clarity and consistency.
    /// - Update all related configs, comments, variables, and function names throughout the codebase to reflect this change.
    /// - This field is a non-nullable list of Bech32-encoded delegatee Gateway addresses.
    #[prost(string, repeated, tag = "4")]
    pub delegatee_gateway_addresses: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Mapping of session end heights to gateways being undelegated from
    /// - Key: Height of the last block of the session when the undelegation transaction was committed
    /// - Value: List of gateways being undelegated from at that session end height
    /// TODO_DOCUMENT(@red-0ne): Document the complete flow and rationale behind this mapping.
    /// - Ensure the documentation explains why tracking pending undelegations by session end height is necessary.
    /// - See: <https://github.com/pokt-network/poktroll/issues/476#issuecomment-2052639906> for context and examples.
    #[prost(map = "uint64, message", tag = "5")]
    pub pending_undelegations: ::std::collections::HashMap<u64, UndelegatingGatewayList>,
    /// Session end height when application initiated unstaking (0 if not unstaking)
    #[prost(uint64, tag = "6")]
    pub unstake_session_end_height: u64,
    /// Information about pending application transfers
    #[prost(message, optional, tag = "7")]
    pub pending_transfer: ::core::option::Option<PendingApplicationTransfer>,
}
impl ::prost::Name for Application {
    const NAME: &'static str = "Application";
    const PACKAGE: &'static str = "pocket.application";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.application.Application".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.application.Application".into()
    }
}
/// UndelegatingGatewayList is used as the Value of `pending_undelegations`.
/// It is required to store a repeated list of strings as a map value.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UndelegatingGatewayList {
    #[prost(string, repeated, tag = "2")]
    pub gateway_addresses: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
impl ::prost::Name for UndelegatingGatewayList {
    const NAME: &'static str = "UndelegatingGatewayList";
    const PACKAGE: &'static str = "pocket.application";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.application.UndelegatingGatewayList".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.application.UndelegatingGatewayList".into()
    }
}
/// PendingTransfer is used to store the details of a pending transfer.
/// It is only intended to be used inside of an Application object.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PendingApplicationTransfer {
    #[prost(string, tag = "1")]
    pub destination_address: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub session_end_height: u64,
}
impl ::prost::Name for PendingApplicationTransfer {
    const NAME: &'static str = "PendingApplicationTransfer";
    const PACKAGE: &'static str = "pocket.application";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.application.PendingApplicationTransfer".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.application.PendingApplicationTransfer".into()
    }
}
/// Undelegation represents a connection between an application and a gateway that
/// is in the process of being removed.
///
/// This record is stored in the undelegation index
/// and used to track and process pending undelegations after the unbonding period has elapsed.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PendingUndelegation {
    /// Address of the application that is undelegating from the gateway.
    #[prost(string, tag = "1")]
    pub application_address: ::prost::alloc::string::String,
    /// Address of the gateway that the application is undelegating from.
    #[prost(string, tag = "2")]
    pub gateway_address: ::prost::alloc::string::String,
}
impl ::prost::Name for PendingUndelegation {
    const NAME: &'static str = "PendingUndelegation";
    const PACKAGE: &'static str = "pocket.application";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.application.PendingUndelegation".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.application.PendingUndelegation".into()
    }
}
/// EventApplicationStaked is emitted when an application is staked or up-staked.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventApplicationStaked {
    #[prost(message, optional, tag = "1")]
    pub application: ::core::option::Option<Application>,
    /// The end height of the session in which the application was staked.
    #[prost(int64, tag = "2")]
    pub session_end_height: i64,
}
impl ::prost::Name for EventApplicationStaked {
    const NAME: &'static str = "EventApplicationStaked";
    const PACKAGE: &'static str = "pocket.application";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.application.EventApplicationStaked".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.application.EventApplicationStaked".into()
    }
}
/// EventRedelegation is an event emitted whenever an application changes its
/// delegatee gateways on chain. This is in response to both a DelegateToGateway
/// and UndelegateFromGateway message.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventRedelegation {
    /// The application which was redelegated.
    #[prost(message, optional, tag = "1")]
    pub application: ::core::option::Option<Application>,
    /// The end height of the session in which the redelegation was committed.
    #[prost(int64, tag = "2")]
    pub session_end_height: i64,
}
impl ::prost::Name for EventRedelegation {
    const NAME: &'static str = "EventRedelegation";
    const PACKAGE: &'static str = "pocket.application";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.application.EventRedelegation".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.application.EventRedelegation".into()
    }
}
/// EventTransferBegin is emitted whenever an application begins a transfer. It
/// includes the source application state immediately after the transfer began.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventTransferBegin {
    #[prost(string, tag = "1")]
    pub source_address: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub destination_address: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub source_application: ::core::option::Option<Application>,
    /// The end height of the session in which the transfer began.
    #[prost(int64, tag = "4")]
    pub session_end_height: i64,
    /// The height at which the transfer will complete.
    #[prost(int64, tag = "5")]
    pub transfer_end_height: i64,
}
impl ::prost::Name for EventTransferBegin {
    const NAME: &'static str = "EventTransferBegin";
    const PACKAGE: &'static str = "pocket.application";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.application.EventTransferBegin".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.application.EventTransferBegin".into()
    }
}
/// EventTransferEnd is emitted whenever an application transfer is completed. It
/// includes the destination application state at the time the transfer completed.
/// Either EventTransferEnd or EventTransferError will be emitted corresponding to
/// any given EventTransferBegin event.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventTransferEnd {
    #[prost(string, tag = "1")]
    pub source_address: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub destination_address: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub destination_application: ::core::option::Option<Application>,
    /// The end height of the session in which the transfer ended.
    #[prost(int64, tag = "4")]
    pub session_end_height: i64,
    /// The height at which the transfer completed.
    #[prost(int64, tag = "5")]
    pub transfer_end_height: i64,
}
impl ::prost::Name for EventTransferEnd {
    const NAME: &'static str = "EventTransferEnd";
    const PACKAGE: &'static str = "pocket.application";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.application.EventTransferEnd".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.application.EventTransferEnd".into()
    }
}
/// EventTransferError is emitted whenever an application transfer fails. It
/// includes the source application state at the time the transfer failed and
/// the error message.
/// Either EventTransferEnd or EventTransferError will be emitted corresponding to
/// any given EventTransferBegin event.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventTransferError {
    #[prost(string, tag = "1")]
    pub source_address: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub destination_address: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "3")]
    pub source_application: ::core::option::Option<Application>,
    /// The end height of the session in which the transfer failed.
    #[prost(int64, tag = "4")]
    pub session_end_height: i64,
    #[prost(string, tag = "5")]
    pub error: ::prost::alloc::string::String,
}
impl ::prost::Name for EventTransferError {
    const NAME: &'static str = "EventTransferError";
    const PACKAGE: &'static str = "pocket.application";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.application.EventTransferError".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.application.EventTransferError".into()
    }
}
/// EventApplicationUnbondingBegin is emitted when an application begins unbonding.
/// This can be triggered by the commitment of an unstake message or by the application's
/// stake dropping below the minimum. This event signals that an application has begun
/// unbonding. The unbonding period is determined by the shared param,
/// application_unbonding_period_sessions.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventApplicationUnbondingBegin {
    #[prost(message, optional, tag = "1")]
    pub application: ::core::option::Option<Application>,
    #[prost(enumeration = "ApplicationUnbondingReason", tag = "2")]
    pub reason: i32,
    /// The end height of the session in which the unbonding began.
    #[prost(int64, tag = "3")]
    pub session_end_height: i64,
    /// The height at which application unbonding will end.
    #[prost(int64, tag = "4")]
    pub unbonding_end_height: i64,
}
impl ::prost::Name for EventApplicationUnbondingBegin {
    const NAME: &'static str = "EventApplicationUnbondingBegin";
    const PACKAGE: &'static str = "pocket.application";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.application.EventApplicationUnbondingBegin".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.application.EventApplicationUnbondingBegin".into()
    }
}
/// EventApplicationUnbondingEnd is emitted when an application has completed
/// unbonding. The unbonding period is determined by the shared param,
/// application_unbonding_period_sessions.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventApplicationUnbondingEnd {
    #[prost(message, optional, tag = "1")]
    pub application: ::core::option::Option<Application>,
    #[prost(enumeration = "ApplicationUnbondingReason", tag = "2")]
    pub reason: i32,
    /// The end height of the session in which the unbonding ended.
    #[prost(int64, tag = "3")]
    pub session_end_height: i64,
    /// The height at which application unbonding ended.
    #[prost(int64, tag = "4")]
    pub unbonding_end_height: i64,
}
impl ::prost::Name for EventApplicationUnbondingEnd {
    const NAME: &'static str = "EventApplicationUnbondingEnd";
    const PACKAGE: &'static str = "pocket.application";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.application.EventApplicationUnbondingEnd".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.application.EventApplicationUnbondingEnd".into()
    }
}
/// EventApplicationUnbondingCanceled is emitted when an application which was unbonding
/// successfully (re-)stakes before the unbonding period has elapsed. An EventApplicationStaked
/// event will also be emitted immediately after this event.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EventApplicationUnbondingCanceled {
    #[prost(message, optional, tag = "1")]
    pub application: ::core::option::Option<Application>,
    /// The end height of the session in which the unbonding was canceled.
    #[prost(int64, tag = "2")]
    pub session_end_height: i64,
}
impl ::prost::Name for EventApplicationUnbondingCanceled {
    const NAME: &'static str = "EventApplicationUnbondingCanceled";
    const PACKAGE: &'static str = "pocket.application";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.application.EventApplicationUnbondingCanceled".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.application.EventApplicationUnbondingCanceled".into()
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ApplicationUnbondingReason {
    Elective = 0,
    BelowMinStake = 1,
}
impl ApplicationUnbondingReason {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Elective => "APPLICATION_UNBONDING_REASON_ELECTIVE",
            Self::BelowMinStake => "APPLICATION_UNBONDING_REASON_BELOW_MIN_STAKE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "APPLICATION_UNBONDING_REASON_ELECTIVE" => Some(Self::Elective),
            "APPLICATION_UNBONDING_REASON_BELOW_MIN_STAKE" => Some(Self::BelowMinStake),
            _ => None,
        }
    }
}
/// Params defines the parameters for the module.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Params {
    /// max_delegated_gateways defines the maximum number of gateways that a single
    /// application can delegate to. This is used to prevent performance issues
    /// in case the relay ring signature becomes too large.
    #[prost(uint64, tag = "1")]
    pub max_delegated_gateways: u64,
    /// min_stake is the minimum stake in upokt that an application must have to remain staked.
    #[prost(message, optional, tag = "2")]
    pub min_stake: ::core::option::Option<super::super::cosmos::base::v1beta1::Coin>,
}
impl ::prost::Name for Params {
    const NAME: &'static str = "Params";
    const PACKAGE: &'static str = "pocket.application";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.application.Params".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.application.Params".into()
    }
}
/// GenesisState defines the application module's genesis state.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenesisState {
    /// params defines all the parameters of the module.
    #[prost(message, optional, tag = "1")]
    pub params: ::core::option::Option<Params>,
    #[prost(message, repeated, tag = "2")]
    pub application_list: ::prost::alloc::vec::Vec<Application>,
}
impl ::prost::Name for GenesisState {
    const NAME: &'static str = "GenesisState";
    const PACKAGE: &'static str = "pocket.application";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.application.GenesisState".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.application.GenesisState".into()
    }
}
/// QueryParamsRequest is request type for the Query/Params RPC method.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryParamsRequest {}
impl ::prost::Name for QueryParamsRequest {
    const NAME: &'static str = "QueryParamsRequest";
    const PACKAGE: &'static str = "pocket.application";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.application.QueryParamsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.application.QueryParamsRequest".into()
    }
}
/// QueryParamsResponse is response type for the Query/Params RPC method.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryParamsResponse {
    /// params holds all the parameters of this module.
    #[prost(message, optional, tag = "1")]
    pub params: ::core::option::Option<Params>,
}
impl ::prost::Name for QueryParamsResponse {
    const NAME: &'static str = "QueryParamsResponse";
    const PACKAGE: &'static str = "pocket.application";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.application.QueryParamsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.application.QueryParamsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryGetApplicationRequest {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryGetApplicationRequest {
    const NAME: &'static str = "QueryGetApplicationRequest";
    const PACKAGE: &'static str = "pocket.application";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.application.QueryGetApplicationRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.application.QueryGetApplicationRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryGetApplicationResponse {
    #[prost(message, optional, tag = "1")]
    pub application: ::core::option::Option<Application>,
}
impl ::prost::Name for QueryGetApplicationResponse {
    const NAME: &'static str = "QueryGetApplicationResponse";
    const PACKAGE: &'static str = "pocket.application";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.application.QueryGetApplicationResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.application.QueryGetApplicationResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAllApplicationsRequest {
    #[prost(message, optional, tag = "1")]
    pub pagination: ::core::option::Option<
        super::super::cosmos::base::query::v1beta1::PageRequest,
    >,
    /// TODO_MAINNET(@adshmh): rename this field to `gateway_address_delegated_to`
    /// delegatee_gateway_address, if specified, filters the application list to only include those with delegation to the specified gateway address.
    #[prost(string, tag = "2")]
    pub delegatee_gateway_address: ::prost::alloc::string::String,
}
impl ::prost::Name for QueryAllApplicationsRequest {
    const NAME: &'static str = "QueryAllApplicationsRequest";
    const PACKAGE: &'static str = "pocket.application";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.application.QueryAllApplicationsRequest".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.application.QueryAllApplicationsRequest".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAllApplicationsResponse {
    #[prost(message, repeated, tag = "1")]
    pub applications: ::prost::alloc::vec::Vec<Application>,
    #[prost(message, optional, tag = "2")]
    pub pagination: ::core::option::Option<
        super::super::cosmos::base::query::v1beta1::PageResponse,
    >,
}
impl ::prost::Name for QueryAllApplicationsResponse {
    const NAME: &'static str = "QueryAllApplicationsResponse";
    const PACKAGE: &'static str = "pocket.application";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.application.QueryAllApplicationsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.application.QueryAllApplicationsResponse".into()
    }
}
/// Generated client implementations.
pub mod query_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Query defines the gRPC querier service.
    #[derive(Debug, Clone)]
    pub struct QueryClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl QueryClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> QueryClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> QueryClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            QueryClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Parameters queries the parameters of the module.
        pub async fn params(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryParamsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryParamsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pocket.application.Query/Params",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pocket.application.Query", "Params"));
            self.inner.unary(req, path, codec).await
        }
        /// Queries a list of Application items.
        pub async fn application(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryGetApplicationRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryGetApplicationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pocket.application.Query/Application",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pocket.application.Query", "Application"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn all_applications(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryAllApplicationsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryAllApplicationsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pocket.application.Query/AllApplications",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pocket.application.Query", "AllApplications"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// MsgUpdateParams is the Msg/UpdateParams request type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUpdateParams {
    /// authority is the address that controls the module (defaults to x/gov unless overwritten).
    #[prost(string, tag = "1")]
    pub authority: ::prost::alloc::string::String,
    /// params defines the x/application parameters to update.
    /// NOTE: All parameters must be supplied.
    #[prost(message, optional, tag = "2")]
    pub params: ::core::option::Option<Params>,
}
impl ::prost::Name for MsgUpdateParams {
    const NAME: &'static str = "MsgUpdateParams";
    const PACKAGE: &'static str = "pocket.application";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.application.MsgUpdateParams".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.application.MsgUpdateParams".into()
    }
}
/// MsgUpdateParamsResponse defines the response structure for executing a
/// MsgUpdateParams message.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct MsgUpdateParamsResponse {}
impl ::prost::Name for MsgUpdateParamsResponse {
    const NAME: &'static str = "MsgUpdateParamsResponse";
    const PACKAGE: &'static str = "pocket.application";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.application.MsgUpdateParamsResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.application.MsgUpdateParamsResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgStakeApplication {
    /// The Bech32 address of the application.
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
    /// The total amount of uPOKT the application has staked. Must be ≥ to the current amount that the application has staked (if any)
    #[prost(message, optional, tag = "2")]
    pub stake: ::core::option::Option<super::super::cosmos::base::v1beta1::Coin>,
    /// The list of services this application is staked to request service for
    #[prost(message, repeated, tag = "3")]
    pub services: ::prost::alloc::vec::Vec<super::shared::ApplicationServiceConfig>,
}
impl ::prost::Name for MsgStakeApplication {
    const NAME: &'static str = "MsgStakeApplication";
    const PACKAGE: &'static str = "pocket.application";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.application.MsgStakeApplication".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.application.MsgStakeApplication".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgStakeApplicationResponse {
    #[prost(message, optional, tag = "1")]
    pub application: ::core::option::Option<Application>,
}
impl ::prost::Name for MsgStakeApplicationResponse {
    const NAME: &'static str = "MsgStakeApplicationResponse";
    const PACKAGE: &'static str = "pocket.application";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.application.MsgStakeApplicationResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.application.MsgStakeApplicationResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUnstakeApplication {
    #[prost(string, tag = "1")]
    pub address: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgUnstakeApplication {
    const NAME: &'static str = "MsgUnstakeApplication";
    const PACKAGE: &'static str = "pocket.application";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.application.MsgUnstakeApplication".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.application.MsgUnstakeApplication".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUnstakeApplicationResponse {
    #[prost(message, optional, tag = "1")]
    pub application: ::core::option::Option<Application>,
}
impl ::prost::Name for MsgUnstakeApplicationResponse {
    const NAME: &'static str = "MsgUnstakeApplicationResponse";
    const PACKAGE: &'static str = "pocket.application";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.application.MsgUnstakeApplicationResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.application.MsgUnstakeApplicationResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgDelegateToGateway {
    /// The Bech32 address of the application.
    #[prost(string, tag = "1")]
    pub app_address: ::prost::alloc::string::String,
    /// The Bech32 address of the gateway the application wants to delegate to.
    #[prost(string, tag = "2")]
    pub gateway_address: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgDelegateToGateway {
    const NAME: &'static str = "MsgDelegateToGateway";
    const PACKAGE: &'static str = "pocket.application";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.application.MsgDelegateToGateway".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.application.MsgDelegateToGateway".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgDelegateToGatewayResponse {
    #[prost(message, optional, tag = "1")]
    pub application: ::core::option::Option<Application>,
}
impl ::prost::Name for MsgDelegateToGatewayResponse {
    const NAME: &'static str = "MsgDelegateToGatewayResponse";
    const PACKAGE: &'static str = "pocket.application";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.application.MsgDelegateToGatewayResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.application.MsgDelegateToGatewayResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUndelegateFromGateway {
    /// The Bech32 address of the application.
    #[prost(string, tag = "1")]
    pub app_address: ::prost::alloc::string::String,
    /// The Bech32 address of the gateway the application wants to undelegate from.
    #[prost(string, tag = "2")]
    pub gateway_address: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgUndelegateFromGateway {
    const NAME: &'static str = "MsgUndelegateFromGateway";
    const PACKAGE: &'static str = "pocket.application";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.application.MsgUndelegateFromGateway".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.application.MsgUndelegateFromGateway".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUndelegateFromGatewayResponse {
    #[prost(message, optional, tag = "1")]
    pub application: ::core::option::Option<Application>,
}
impl ::prost::Name for MsgUndelegateFromGatewayResponse {
    const NAME: &'static str = "MsgUndelegateFromGatewayResponse";
    const PACKAGE: &'static str = "pocket.application";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.application.MsgUndelegateFromGatewayResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.application.MsgUndelegateFromGatewayResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgTransferApplication {
    #[prost(string, tag = "1")]
    pub source_address: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub destination_address: ::prost::alloc::string::String,
}
impl ::prost::Name for MsgTransferApplication {
    const NAME: &'static str = "MsgTransferApplication";
    const PACKAGE: &'static str = "pocket.application";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.application.MsgTransferApplication".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.application.MsgTransferApplication".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgTransferApplicationResponse {
    #[prost(message, optional, tag = "1")]
    pub application: ::core::option::Option<Application>,
}
impl ::prost::Name for MsgTransferApplicationResponse {
    const NAME: &'static str = "MsgTransferApplicationResponse";
    const PACKAGE: &'static str = "pocket.application";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.application.MsgTransferApplicationResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.application.MsgTransferApplicationResponse".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUpdateParam {
    /// authority is the address that controls the module (defaults to x/gov unless overwritten).
    #[prost(string, tag = "1")]
    pub authority: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(oneof = "msg_update_param::AsType", tags = "3, 4")]
    pub as_type: ::core::option::Option<msg_update_param::AsType>,
}
/// Nested message and enum types in `MsgUpdateParam`.
pub mod msg_update_param {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum AsType {
        #[prost(uint64, tag = "3")]
        AsUint64(u64),
        #[prost(message, tag = "4")]
        AsCoin(super::super::super::cosmos::base::v1beta1::Coin),
    }
}
impl ::prost::Name for MsgUpdateParam {
    const NAME: &'static str = "MsgUpdateParam";
    const PACKAGE: &'static str = "pocket.application";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.application.MsgUpdateParam".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.application.MsgUpdateParam".into()
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MsgUpdateParamResponse {
    #[prost(message, optional, tag = "1")]
    pub params: ::core::option::Option<Params>,
}
impl ::prost::Name for MsgUpdateParamResponse {
    const NAME: &'static str = "MsgUpdateParamResponse";
    const PACKAGE: &'static str = "pocket.application";
    fn full_name() -> ::prost::alloc::string::String {
        "pocket.application.MsgUpdateParamResponse".into()
    }
    fn type_url() -> ::prost::alloc::string::String {
        "/pocket.application.MsgUpdateParamResponse".into()
    }
}
/// Generated client implementations.
pub mod msg_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Msg defines the Msg service.
    #[derive(Debug, Clone)]
    pub struct MsgClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl MsgClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> MsgClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> MsgClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            MsgClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// UpdateParams defines a (governance) operation for updating the module
        /// parameters. The authority defaults to the x/gov module account.
        pub async fn update_params(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgUpdateParams>,
        ) -> std::result::Result<
            tonic::Response<super::MsgUpdateParamsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pocket.application.Msg/UpdateParams",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pocket.application.Msg", "UpdateParams"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn stake_application(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgStakeApplication>,
        ) -> std::result::Result<
            tonic::Response<super::MsgStakeApplicationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pocket.application.Msg/StakeApplication",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pocket.application.Msg", "StakeApplication"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn unstake_application(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgUnstakeApplication>,
        ) -> std::result::Result<
            tonic::Response<super::MsgUnstakeApplicationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pocket.application.Msg/UnstakeApplication",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pocket.application.Msg", "UnstakeApplication"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn delegate_to_gateway(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgDelegateToGateway>,
        ) -> std::result::Result<
            tonic::Response<super::MsgDelegateToGatewayResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pocket.application.Msg/DelegateToGateway",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pocket.application.Msg", "DelegateToGateway"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn undelegate_from_gateway(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgUndelegateFromGateway>,
        ) -> std::result::Result<
            tonic::Response<super::MsgUndelegateFromGatewayResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pocket.application.Msg/UndelegateFromGateway",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("pocket.application.Msg", "UndelegateFromGateway"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn transfer_application(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgTransferApplication>,
        ) -> std::result::Result<
            tonic::Response<super::MsgTransferApplicationResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pocket.application.Msg/TransferApplication",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("pocket.application.Msg", "TransferApplication"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn update_param(
            &mut self,
            request: impl tonic::IntoRequest<super::MsgUpdateParam>,
        ) -> std::result::Result<
            tonic::Response<super::MsgUpdateParamResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/pocket.application.Msg/UpdateParam",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("pocket.application.Msg", "UpdateParam"));
            self.inner.unary(req, path, codec).await
        }
    }
}
